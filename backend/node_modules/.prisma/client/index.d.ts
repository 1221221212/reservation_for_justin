
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Store
 * 店舗テーブル
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model UserAccount
 * ユーザーアカウントテーブル
 */
export type UserAccount = $Result.DefaultSelection<Prisma.$UserAccountPayload>
/**
 * Model SeatAttributeGroup
 * 座席属性グループ
 */
export type SeatAttributeGroup = $Result.DefaultSelection<Prisma.$SeatAttributeGroupPayload>
/**
 * Model SeatAttribute
 * 座席属性
 */
export type SeatAttribute = $Result.DefaultSelection<Prisma.$SeatAttributePayload>
/**
 * Model SeatAttributeAssignment
 * 中間テーブル: 座席⇔属性の割り当て
 */
export type SeatAttributeAssignment = $Result.DefaultSelection<Prisma.$SeatAttributeAssignmentPayload>
/**
 * Model Seat
 * 座席テーブル
 */
export type Seat = $Result.DefaultSelection<Prisma.$SeatPayload>
/**
 * Model Layout
 * レイアウト
 */
export type Layout = $Result.DefaultSelection<Prisma.$LayoutPayload>
/**
 * Model LayoutSeat
 * レイアウト⇔座席 の中間テーブル
 */
export type LayoutSeat = $Result.DefaultSelection<Prisma.$LayoutSeatPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  owner: 'owner',
  manager: 'manager',
  staff: 'staff'
};

export type Role = (typeof Role)[keyof typeof Role]


export const StoreStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  CLOSED: 'CLOSED'
};

export type StoreStatus = (typeof StoreStatus)[keyof typeof StoreStatus]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const AttributeStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type AttributeStatus = (typeof AttributeStatus)[keyof typeof AttributeStatus]


export const SelectionType: {
  single: 'single',
  multiple: 'multiple'
};

export type SelectionType = (typeof SelectionType)[keyof typeof SelectionType]


export const SeatStatus: {
  active: 'active',
  inactive: 'inactive',
  suspended: 'suspended'
};

export type SeatStatus = (typeof SeatStatus)[keyof typeof SeatStatus]


export const LayoutStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type LayoutStatus = (typeof LayoutStatus)[keyof typeof LayoutStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type StoreStatus = $Enums.StoreStatus

export const StoreStatus: typeof $Enums.StoreStatus

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type AttributeStatus = $Enums.AttributeStatus

export const AttributeStatus: typeof $Enums.AttributeStatus

export type SelectionType = $Enums.SelectionType

export const SelectionType: typeof $Enums.SelectionType

export type SeatStatus = $Enums.SeatStatus

export const SeatStatus: typeof $Enums.SeatStatus

export type LayoutStatus = $Enums.LayoutStatus

export const LayoutStatus: typeof $Enums.LayoutStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Stores
 * const stores = await prisma.store.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Stores
   * const stores = await prisma.store.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAccount`: Exposes CRUD operations for the **UserAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAccounts
    * const userAccounts = await prisma.userAccount.findMany()
    * ```
    */
  get userAccount(): Prisma.UserAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seatAttributeGroup`: Exposes CRUD operations for the **SeatAttributeGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeatAttributeGroups
    * const seatAttributeGroups = await prisma.seatAttributeGroup.findMany()
    * ```
    */
  get seatAttributeGroup(): Prisma.SeatAttributeGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seatAttribute`: Exposes CRUD operations for the **SeatAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeatAttributes
    * const seatAttributes = await prisma.seatAttribute.findMany()
    * ```
    */
  get seatAttribute(): Prisma.SeatAttributeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seatAttributeAssignment`: Exposes CRUD operations for the **SeatAttributeAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeatAttributeAssignments
    * const seatAttributeAssignments = await prisma.seatAttributeAssignment.findMany()
    * ```
    */
  get seatAttributeAssignment(): Prisma.SeatAttributeAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seat`: Exposes CRUD operations for the **Seat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seats
    * const seats = await prisma.seat.findMany()
    * ```
    */
  get seat(): Prisma.SeatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.layout`: Exposes CRUD operations for the **Layout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Layouts
    * const layouts = await prisma.layout.findMany()
    * ```
    */
  get layout(): Prisma.LayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.layoutSeat`: Exposes CRUD operations for the **LayoutSeat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LayoutSeats
    * const layoutSeats = await prisma.layoutSeat.findMany()
    * ```
    */
  get layoutSeat(): Prisma.LayoutSeatDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Store: 'Store',
    UserAccount: 'UserAccount',
    SeatAttributeGroup: 'SeatAttributeGroup',
    SeatAttribute: 'SeatAttribute',
    SeatAttributeAssignment: 'SeatAttributeAssignment',
    Seat: 'Seat',
    Layout: 'Layout',
    LayoutSeat: 'LayoutSeat'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "store" | "userAccount" | "seatAttributeGroup" | "seatAttribute" | "seatAttributeAssignment" | "seat" | "layout" | "layoutSeat"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      UserAccount: {
        payload: Prisma.$UserAccountPayload<ExtArgs>
        fields: Prisma.UserAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findFirst: {
            args: Prisma.UserAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          findMany: {
            args: Prisma.UserAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          create: {
            args: Prisma.UserAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          createMany: {
            args: Prisma.UserAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          delete: {
            args: Prisma.UserAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          update: {
            args: Prisma.UserAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          deleteMany: {
            args: Prisma.UserAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>[]
          }
          upsert: {
            args: Prisma.UserAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAccountPayload>
          }
          aggregate: {
            args: Prisma.UserAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAccount>
          }
          groupBy: {
            args: Prisma.UserAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAccountCountArgs<ExtArgs>
            result: $Utils.Optional<UserAccountCountAggregateOutputType> | number
          }
        }
      }
      SeatAttributeGroup: {
        payload: Prisma.$SeatAttributeGroupPayload<ExtArgs>
        fields: Prisma.SeatAttributeGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatAttributeGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatAttributeGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload>
          }
          findFirst: {
            args: Prisma.SeatAttributeGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatAttributeGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload>
          }
          findMany: {
            args: Prisma.SeatAttributeGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload>[]
          }
          create: {
            args: Prisma.SeatAttributeGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload>
          }
          createMany: {
            args: Prisma.SeatAttributeGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeatAttributeGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload>[]
          }
          delete: {
            args: Prisma.SeatAttributeGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload>
          }
          update: {
            args: Prisma.SeatAttributeGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload>
          }
          deleteMany: {
            args: Prisma.SeatAttributeGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatAttributeGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeatAttributeGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload>[]
          }
          upsert: {
            args: Prisma.SeatAttributeGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeGroupPayload>
          }
          aggregate: {
            args: Prisma.SeatAttributeGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeatAttributeGroup>
          }
          groupBy: {
            args: Prisma.SeatAttributeGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatAttributeGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatAttributeGroupCountArgs<ExtArgs>
            result: $Utils.Optional<SeatAttributeGroupCountAggregateOutputType> | number
          }
        }
      }
      SeatAttribute: {
        payload: Prisma.$SeatAttributePayload<ExtArgs>
        fields: Prisma.SeatAttributeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatAttributeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatAttributeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload>
          }
          findFirst: {
            args: Prisma.SeatAttributeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatAttributeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload>
          }
          findMany: {
            args: Prisma.SeatAttributeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload>[]
          }
          create: {
            args: Prisma.SeatAttributeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload>
          }
          createMany: {
            args: Prisma.SeatAttributeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeatAttributeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload>[]
          }
          delete: {
            args: Prisma.SeatAttributeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload>
          }
          update: {
            args: Prisma.SeatAttributeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload>
          }
          deleteMany: {
            args: Prisma.SeatAttributeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatAttributeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeatAttributeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload>[]
          }
          upsert: {
            args: Prisma.SeatAttributeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributePayload>
          }
          aggregate: {
            args: Prisma.SeatAttributeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeatAttribute>
          }
          groupBy: {
            args: Prisma.SeatAttributeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatAttributeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatAttributeCountArgs<ExtArgs>
            result: $Utils.Optional<SeatAttributeCountAggregateOutputType> | number
          }
        }
      }
      SeatAttributeAssignment: {
        payload: Prisma.$SeatAttributeAssignmentPayload<ExtArgs>
        fields: Prisma.SeatAttributeAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatAttributeAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatAttributeAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload>
          }
          findFirst: {
            args: Prisma.SeatAttributeAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatAttributeAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload>
          }
          findMany: {
            args: Prisma.SeatAttributeAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload>[]
          }
          create: {
            args: Prisma.SeatAttributeAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload>
          }
          createMany: {
            args: Prisma.SeatAttributeAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeatAttributeAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload>[]
          }
          delete: {
            args: Prisma.SeatAttributeAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload>
          }
          update: {
            args: Prisma.SeatAttributeAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.SeatAttributeAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatAttributeAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeatAttributeAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.SeatAttributeAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatAttributeAssignmentPayload>
          }
          aggregate: {
            args: Prisma.SeatAttributeAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeatAttributeAssignment>
          }
          groupBy: {
            args: Prisma.SeatAttributeAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatAttributeAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatAttributeAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<SeatAttributeAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Seat: {
        payload: Prisma.$SeatPayload<ExtArgs>
        fields: Prisma.SeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          findFirst: {
            args: Prisma.SeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          findMany: {
            args: Prisma.SeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>[]
          }
          create: {
            args: Prisma.SeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          createMany: {
            args: Prisma.SeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>[]
          }
          delete: {
            args: Prisma.SeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          update: {
            args: Prisma.SeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          deleteMany: {
            args: Prisma.SeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>[]
          }
          upsert: {
            args: Prisma.SeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          aggregate: {
            args: Prisma.SeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeat>
          }
          groupBy: {
            args: Prisma.SeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatCountArgs<ExtArgs>
            result: $Utils.Optional<SeatCountAggregateOutputType> | number
          }
        }
      }
      Layout: {
        payload: Prisma.$LayoutPayload<ExtArgs>
        fields: Prisma.LayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          findFirst: {
            args: Prisma.LayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          findMany: {
            args: Prisma.LayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>[]
          }
          create: {
            args: Prisma.LayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          createMany: {
            args: Prisma.LayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>[]
          }
          delete: {
            args: Prisma.LayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          update: {
            args: Prisma.LayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          deleteMany: {
            args: Prisma.LayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LayoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>[]
          }
          upsert: {
            args: Prisma.LayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutPayload>
          }
          aggregate: {
            args: Prisma.LayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLayout>
          }
          groupBy: {
            args: Prisma.LayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<LayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.LayoutCountArgs<ExtArgs>
            result: $Utils.Optional<LayoutCountAggregateOutputType> | number
          }
        }
      }
      LayoutSeat: {
        payload: Prisma.$LayoutSeatPayload<ExtArgs>
        fields: Prisma.LayoutSeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LayoutSeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LayoutSeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload>
          }
          findFirst: {
            args: Prisma.LayoutSeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LayoutSeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload>
          }
          findMany: {
            args: Prisma.LayoutSeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload>[]
          }
          create: {
            args: Prisma.LayoutSeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload>
          }
          createMany: {
            args: Prisma.LayoutSeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LayoutSeatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload>[]
          }
          delete: {
            args: Prisma.LayoutSeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload>
          }
          update: {
            args: Prisma.LayoutSeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload>
          }
          deleteMany: {
            args: Prisma.LayoutSeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LayoutSeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LayoutSeatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload>[]
          }
          upsert: {
            args: Prisma.LayoutSeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayoutSeatPayload>
          }
          aggregate: {
            args: Prisma.LayoutSeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLayoutSeat>
          }
          groupBy: {
            args: Prisma.LayoutSeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<LayoutSeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.LayoutSeatCountArgs<ExtArgs>
            result: $Utils.Optional<LayoutSeatCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    store?: StoreOmit
    userAccount?: UserAccountOmit
    seatAttributeGroup?: SeatAttributeGroupOmit
    seatAttribute?: SeatAttributeOmit
    seatAttributeAssignment?: SeatAttributeAssignmentOmit
    seat?: SeatOmit
    layout?: LayoutOmit
    layoutSeat?: LayoutSeatOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    users: number
    seatAttributeGroups: number
    seatAttributes: number
    seats: number
    layouts: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | StoreCountOutputTypeCountUsersArgs
    seatAttributeGroups?: boolean | StoreCountOutputTypeCountSeatAttributeGroupsArgs
    seatAttributes?: boolean | StoreCountOutputTypeCountSeatAttributesArgs
    seats?: boolean | StoreCountOutputTypeCountSeatsArgs
    layouts?: boolean | StoreCountOutputTypeCountLayoutsArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccountWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSeatAttributeGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatAttributeGroupWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSeatAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatAttributeWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountLayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayoutWhereInput
  }


  /**
   * Count Type SeatAttributeGroupCountOutputType
   */

  export type SeatAttributeGroupCountOutputType = {
    attributes: number
  }

  export type SeatAttributeGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | SeatAttributeGroupCountOutputTypeCountAttributesArgs
  }

  // Custom InputTypes
  /**
   * SeatAttributeGroupCountOutputType without action
   */
  export type SeatAttributeGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroupCountOutputType
     */
    select?: SeatAttributeGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeatAttributeGroupCountOutputType without action
   */
  export type SeatAttributeGroupCountOutputTypeCountAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatAttributeWhereInput
  }


  /**
   * Count Type SeatAttributeCountOutputType
   */

  export type SeatAttributeCountOutputType = {
    assignments: number
  }

  export type SeatAttributeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | SeatAttributeCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * SeatAttributeCountOutputType without action
   */
  export type SeatAttributeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeCountOutputType
     */
    select?: SeatAttributeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeatAttributeCountOutputType without action
   */
  export type SeatAttributeCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatAttributeAssignmentWhereInput
  }


  /**
   * Count Type SeatCountOutputType
   */

  export type SeatCountOutputType = {
    attributes: number
    layouts: number
  }

  export type SeatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | SeatCountOutputTypeCountAttributesArgs
    layouts?: boolean | SeatCountOutputTypeCountLayoutsArgs
  }

  // Custom InputTypes
  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatCountOutputType
     */
    select?: SeatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeCountAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatAttributeAssignmentWhereInput
  }

  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeCountLayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayoutSeatWhereInput
  }


  /**
   * Count Type LayoutCountOutputType
   */

  export type LayoutCountOutputType = {
    seats: number
  }

  export type LayoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seats?: boolean | LayoutCountOutputTypeCountSeatsArgs
  }

  // Custom InputTypes
  /**
   * LayoutCountOutputType without action
   */
  export type LayoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutCountOutputType
     */
    select?: LayoutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LayoutCountOutputType without action
   */
  export type LayoutCountOutputTypeCountSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayoutSeatWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreAvgAggregateOutputType = {
    id: number | null
  }

  export type StoreSumAggregateOutputType = {
    id: bigint | null
  }

  export type StoreMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    status: $Enums.StoreStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    status: $Enums.StoreStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreAvgAggregateInputType = {
    id?: true
  }

  export type StoreSumAggregateInputType = {
    id?: true
  }

  export type StoreMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _avg?: StoreAvgAggregateInputType
    _sum?: StoreSumAggregateInputType
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: bigint
    name: string
    status: $Enums.StoreStatus
    createdAt: Date
    updatedAt: Date
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Store$usersArgs<ExtArgs>
    seatAttributeGroups?: boolean | Store$seatAttributeGroupsArgs<ExtArgs>
    seatAttributes?: boolean | Store$seatAttributesArgs<ExtArgs>
    seats?: boolean | Store$seatsArgs<ExtArgs>
    layouts?: boolean | Store$layoutsArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["store"]>
  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Store$usersArgs<ExtArgs>
    seatAttributeGroups?: boolean | Store$seatAttributeGroupsArgs<ExtArgs>
    seatAttributes?: boolean | Store$seatAttributesArgs<ExtArgs>
    seats?: boolean | Store$seatsArgs<ExtArgs>
    layouts?: boolean | Store$layoutsArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      users: Prisma.$UserAccountPayload<ExtArgs>[]
      seatAttributeGroups: Prisma.$SeatAttributeGroupPayload<ExtArgs>[]
      seatAttributes: Prisma.$SeatAttributePayload<ExtArgs>[]
      seats: Prisma.$SeatPayload<ExtArgs>[]
      layouts: Prisma.$LayoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      status: $Enums.StoreStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {StoreUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Store$usersArgs<ExtArgs> = {}>(args?: Subset<T, Store$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seatAttributeGroups<T extends Store$seatAttributeGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Store$seatAttributeGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seatAttributes<T extends Store$seatAttributesArgs<ExtArgs> = {}>(args?: Subset<T, Store$seatAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seats<T extends Store$seatsArgs<ExtArgs> = {}>(args?: Subset<T, Store$seatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    layouts<T extends Store$layoutsArgs<ExtArgs> = {}>(args?: Subset<T, Store$layoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'BigInt'>
    readonly name: FieldRef<"Store", 'String'>
    readonly status: FieldRef<"Store", 'StoreStatus'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store updateManyAndReturn
   */
  export type StoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Store.users
   */
  export type Store$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    where?: UserAccountWhereInput
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    cursor?: UserAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * Store.seatAttributeGroups
   */
  export type Store$seatAttributeGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    where?: SeatAttributeGroupWhereInput
    orderBy?: SeatAttributeGroupOrderByWithRelationInput | SeatAttributeGroupOrderByWithRelationInput[]
    cursor?: SeatAttributeGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatAttributeGroupScalarFieldEnum | SeatAttributeGroupScalarFieldEnum[]
  }

  /**
   * Store.seatAttributes
   */
  export type Store$seatAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    where?: SeatAttributeWhereInput
    orderBy?: SeatAttributeOrderByWithRelationInput | SeatAttributeOrderByWithRelationInput[]
    cursor?: SeatAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatAttributeScalarFieldEnum | SeatAttributeScalarFieldEnum[]
  }

  /**
   * Store.seats
   */
  export type Store$seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    where?: SeatWhereInput
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    cursor?: SeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Store.layouts
   */
  export type Store$layoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    where?: LayoutWhereInput
    orderBy?: LayoutOrderByWithRelationInput | LayoutOrderByWithRelationInput[]
    cursor?: LayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[]
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model UserAccount
   */

  export type AggregateUserAccount = {
    _count: UserAccountCountAggregateOutputType | null
    _avg: UserAccountAvgAggregateOutputType | null
    _sum: UserAccountSumAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  export type UserAccountAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type UserAccountSumAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
  }

  export type UserAccountMinAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    role: $Enums.Role | null
    userId: string | null
    username: string | null
    passwordHash: string | null
    status: $Enums.UserStatus | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAccountMaxAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    role: $Enums.Role | null
    userId: string | null
    username: string | null
    passwordHash: string | null
    status: $Enums.UserStatus | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAccountCountAggregateOutputType = {
    id: number
    storeId: number
    role: number
    userId: number
    username: number
    passwordHash: number
    status: number
    isLocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAccountAvgAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type UserAccountSumAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type UserAccountMinAggregateInputType = {
    id?: true
    storeId?: true
    role?: true
    userId?: true
    username?: true
    passwordHash?: true
    status?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAccountMaxAggregateInputType = {
    id?: true
    storeId?: true
    role?: true
    userId?: true
    username?: true
    passwordHash?: true
    status?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAccountCountAggregateInputType = {
    id?: true
    storeId?: true
    role?: true
    userId?: true
    username?: true
    passwordHash?: true
    status?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccount to aggregate.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAccounts
    **/
    _count?: true | UserAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAccountMaxAggregateInputType
  }

  export type GetUserAccountAggregateType<T extends UserAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAccount[P]>
      : GetScalarType<T[P], AggregateUserAccount[P]>
  }




  export type UserAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAccountWhereInput
    orderBy?: UserAccountOrderByWithAggregationInput | UserAccountOrderByWithAggregationInput[]
    by: UserAccountScalarFieldEnum[] | UserAccountScalarFieldEnum
    having?: UserAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAccountCountAggregateInputType | true
    _avg?: UserAccountAvgAggregateInputType
    _sum?: UserAccountSumAggregateInputType
    _min?: UserAccountMinAggregateInputType
    _max?: UserAccountMaxAggregateInputType
  }

  export type UserAccountGroupByOutputType = {
    id: bigint
    storeId: bigint | null
    role: $Enums.Role
    userId: string
    username: string
    passwordHash: string
    status: $Enums.UserStatus
    isLocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserAccountCountAggregateOutputType | null
    _avg: UserAccountAvgAggregateOutputType | null
    _sum: UserAccountSumAggregateOutputType | null
    _min: UserAccountMinAggregateOutputType | null
    _max: UserAccountMaxAggregateOutputType | null
  }

  type GetUserAccountGroupByPayload<T extends UserAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
            : GetScalarType<T[P], UserAccountGroupByOutputType[P]>
        }
      >
    >


  export type UserAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    role?: boolean
    userId?: boolean
    username?: boolean
    passwordHash?: boolean
    status?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | UserAccount$storeArgs<ExtArgs>
  }, ExtArgs["result"]["userAccount"]>

  export type UserAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    role?: boolean
    userId?: boolean
    username?: boolean
    passwordHash?: boolean
    status?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | UserAccount$storeArgs<ExtArgs>
  }, ExtArgs["result"]["userAccount"]>

  export type UserAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    role?: boolean
    userId?: boolean
    username?: boolean
    passwordHash?: boolean
    status?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | UserAccount$storeArgs<ExtArgs>
  }, ExtArgs["result"]["userAccount"]>

  export type UserAccountSelectScalar = {
    id?: boolean
    storeId?: boolean
    role?: boolean
    userId?: boolean
    username?: boolean
    passwordHash?: boolean
    status?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "role" | "userId" | "username" | "passwordHash" | "status" | "isLocked" | "createdAt" | "updatedAt", ExtArgs["result"]["userAccount"]>
  export type UserAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | UserAccount$storeArgs<ExtArgs>
  }
  export type UserAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | UserAccount$storeArgs<ExtArgs>
  }
  export type UserAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | UserAccount$storeArgs<ExtArgs>
  }

  export type $UserAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAccount"
    objects: {
      store: Prisma.$StorePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      storeId: bigint | null
      role: $Enums.Role
      userId: string
      username: string
      passwordHash: string
      status: $Enums.UserStatus
      isLocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAccount"]>
    composites: {}
  }

  type UserAccountGetPayload<S extends boolean | null | undefined | UserAccountDefaultArgs> = $Result.GetResult<Prisma.$UserAccountPayload, S>

  type UserAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAccountCountAggregateInputType | true
    }

  export interface UserAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAccount'], meta: { name: 'UserAccount' } }
    /**
     * Find zero or one UserAccount that matches the filter.
     * @param {UserAccountFindUniqueArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAccountFindUniqueArgs>(args: SelectSubset<T, UserAccountFindUniqueArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAccountFindUniqueOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAccountFindFirstArgs>(args?: SelectSubset<T, UserAccountFindFirstArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindFirstOrThrowArgs} args - Arguments to find a UserAccount
     * @example
     * // Get one UserAccount
     * const userAccount = await prisma.userAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAccounts
     * const userAccounts = await prisma.userAccount.findMany()
     * 
     * // Get first 10 UserAccounts
     * const userAccounts = await prisma.userAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAccountWithIdOnly = await prisma.userAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAccountFindManyArgs>(args?: SelectSubset<T, UserAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAccount.
     * @param {UserAccountCreateArgs} args - Arguments to create a UserAccount.
     * @example
     * // Create one UserAccount
     * const UserAccount = await prisma.userAccount.create({
     *   data: {
     *     // ... data to create a UserAccount
     *   }
     * })
     * 
     */
    create<T extends UserAccountCreateArgs>(args: SelectSubset<T, UserAccountCreateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAccounts.
     * @param {UserAccountCreateManyArgs} args - Arguments to create many UserAccounts.
     * @example
     * // Create many UserAccounts
     * const userAccount = await prisma.userAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAccountCreateManyArgs>(args?: SelectSubset<T, UserAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAccounts and returns the data saved in the database.
     * @param {UserAccountCreateManyAndReturnArgs} args - Arguments to create many UserAccounts.
     * @example
     * // Create many UserAccounts
     * const userAccount = await prisma.userAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAccounts and only return the `id`
     * const userAccountWithIdOnly = await prisma.userAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAccount.
     * @param {UserAccountDeleteArgs} args - Arguments to delete one UserAccount.
     * @example
     * // Delete one UserAccount
     * const UserAccount = await prisma.userAccount.delete({
     *   where: {
     *     // ... filter to delete one UserAccount
     *   }
     * })
     * 
     */
    delete<T extends UserAccountDeleteArgs>(args: SelectSubset<T, UserAccountDeleteArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAccount.
     * @param {UserAccountUpdateArgs} args - Arguments to update one UserAccount.
     * @example
     * // Update one UserAccount
     * const userAccount = await prisma.userAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAccountUpdateArgs>(args: SelectSubset<T, UserAccountUpdateArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAccounts.
     * @param {UserAccountDeleteManyArgs} args - Arguments to filter UserAccounts to delete.
     * @example
     * // Delete a few UserAccounts
     * const { count } = await prisma.userAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAccountDeleteManyArgs>(args?: SelectSubset<T, UserAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAccounts
     * const userAccount = await prisma.userAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAccountUpdateManyArgs>(args: SelectSubset<T, UserAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAccounts and returns the data updated in the database.
     * @param {UserAccountUpdateManyAndReturnArgs} args - Arguments to update many UserAccounts.
     * @example
     * // Update many UserAccounts
     * const userAccount = await prisma.userAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAccounts and only return the `id`
     * const userAccountWithIdOnly = await prisma.userAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAccount.
     * @param {UserAccountUpsertArgs} args - Arguments to update or create a UserAccount.
     * @example
     * // Update or create a UserAccount
     * const userAccount = await prisma.userAccount.upsert({
     *   create: {
     *     // ... data to create a UserAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAccount we want to update
     *   }
     * })
     */
    upsert<T extends UserAccountUpsertArgs>(args: SelectSubset<T, UserAccountUpsertArgs<ExtArgs>>): Prisma__UserAccountClient<$Result.GetResult<Prisma.$UserAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountCountArgs} args - Arguments to filter UserAccounts to count.
     * @example
     * // Count the number of UserAccounts
     * const count = await prisma.userAccount.count({
     *   where: {
     *     // ... the filter for the UserAccounts we want to count
     *   }
     * })
    **/
    count<T extends UserAccountCountArgs>(
      args?: Subset<T, UserAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAccountAggregateArgs>(args: Subset<T, UserAccountAggregateArgs>): Prisma.PrismaPromise<GetUserAccountAggregateType<T>>

    /**
     * Group by UserAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAccountGroupByArgs['orderBy'] }
        : { orderBy?: UserAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAccount model
   */
  readonly fields: UserAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends UserAccount$storeArgs<ExtArgs> = {}>(args?: Subset<T, UserAccount$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAccount model
   */
  interface UserAccountFieldRefs {
    readonly id: FieldRef<"UserAccount", 'BigInt'>
    readonly storeId: FieldRef<"UserAccount", 'BigInt'>
    readonly role: FieldRef<"UserAccount", 'Role'>
    readonly userId: FieldRef<"UserAccount", 'String'>
    readonly username: FieldRef<"UserAccount", 'String'>
    readonly passwordHash: FieldRef<"UserAccount", 'String'>
    readonly status: FieldRef<"UserAccount", 'UserStatus'>
    readonly isLocked: FieldRef<"UserAccount", 'Boolean'>
    readonly createdAt: FieldRef<"UserAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAccount findUnique
   */
  export type UserAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findUniqueOrThrow
   */
  export type UserAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount findFirst
   */
  export type UserAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findFirstOrThrow
   */
  export type UserAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccount to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAccounts.
     */
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount findMany
   */
  export type UserAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter, which UserAccounts to fetch.
     */
    where?: UserAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAccounts to fetch.
     */
    orderBy?: UserAccountOrderByWithRelationInput | UserAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAccounts.
     */
    cursor?: UserAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAccounts.
     */
    skip?: number
    distinct?: UserAccountScalarFieldEnum | UserAccountScalarFieldEnum[]
  }

  /**
   * UserAccount create
   */
  export type UserAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAccount.
     */
    data: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
  }

  /**
   * UserAccount createMany
   */
  export type UserAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAccounts.
     */
    data: UserAccountCreateManyInput | UserAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAccount createManyAndReturn
   */
  export type UserAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * The data used to create many UserAccounts.
     */
    data: UserAccountCreateManyInput | UserAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAccount update
   */
  export type UserAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAccount.
     */
    data: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
    /**
     * Choose, which UserAccount to update.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount updateMany
   */
  export type UserAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAccounts.
     */
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserAccounts to update
     */
    where?: UserAccountWhereInput
    /**
     * Limit how many UserAccounts to update.
     */
    limit?: number
  }

  /**
   * UserAccount updateManyAndReturn
   */
  export type UserAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * The data used to update UserAccounts.
     */
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyInput>
    /**
     * Filter which UserAccounts to update
     */
    where?: UserAccountWhereInput
    /**
     * Limit how many UserAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAccount upsert
   */
  export type UserAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAccount to update in case it exists.
     */
    where: UserAccountWhereUniqueInput
    /**
     * In case the UserAccount found by the `where` argument doesn't exist, create a new UserAccount with this data.
     */
    create: XOR<UserAccountCreateInput, UserAccountUncheckedCreateInput>
    /**
     * In case the UserAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAccountUpdateInput, UserAccountUncheckedUpdateInput>
  }

  /**
   * UserAccount delete
   */
  export type UserAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
    /**
     * Filter which UserAccount to delete.
     */
    where: UserAccountWhereUniqueInput
  }

  /**
   * UserAccount deleteMany
   */
  export type UserAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAccounts to delete
     */
    where?: UserAccountWhereInput
    /**
     * Limit how many UserAccounts to delete.
     */
    limit?: number
  }

  /**
   * UserAccount.store
   */
  export type UserAccount$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * UserAccount without action
   */
  export type UserAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAccount
     */
    select?: UserAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAccount
     */
    omit?: UserAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAccountInclude<ExtArgs> | null
  }


  /**
   * Model SeatAttributeGroup
   */

  export type AggregateSeatAttributeGroup = {
    _count: SeatAttributeGroupCountAggregateOutputType | null
    _avg: SeatAttributeGroupAvgAggregateOutputType | null
    _sum: SeatAttributeGroupSumAggregateOutputType | null
    _min: SeatAttributeGroupMinAggregateOutputType | null
    _max: SeatAttributeGroupMaxAggregateOutputType | null
  }

  export type SeatAttributeGroupAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type SeatAttributeGroupSumAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
  }

  export type SeatAttributeGroupMinAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    name: string | null
    selectionType: $Enums.SelectionType | null
    status: $Enums.AttributeStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatAttributeGroupMaxAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    name: string | null
    selectionType: $Enums.SelectionType | null
    status: $Enums.AttributeStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatAttributeGroupCountAggregateOutputType = {
    id: number
    storeId: number
    name: number
    selectionType: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeatAttributeGroupAvgAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type SeatAttributeGroupSumAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type SeatAttributeGroupMinAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    selectionType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatAttributeGroupMaxAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    selectionType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatAttributeGroupCountAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    selectionType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeatAttributeGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatAttributeGroup to aggregate.
     */
    where?: SeatAttributeGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributeGroups to fetch.
     */
    orderBy?: SeatAttributeGroupOrderByWithRelationInput | SeatAttributeGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatAttributeGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributeGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributeGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeatAttributeGroups
    **/
    _count?: true | SeatAttributeGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatAttributeGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatAttributeGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatAttributeGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatAttributeGroupMaxAggregateInputType
  }

  export type GetSeatAttributeGroupAggregateType<T extends SeatAttributeGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateSeatAttributeGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeatAttributeGroup[P]>
      : GetScalarType<T[P], AggregateSeatAttributeGroup[P]>
  }




  export type SeatAttributeGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatAttributeGroupWhereInput
    orderBy?: SeatAttributeGroupOrderByWithAggregationInput | SeatAttributeGroupOrderByWithAggregationInput[]
    by: SeatAttributeGroupScalarFieldEnum[] | SeatAttributeGroupScalarFieldEnum
    having?: SeatAttributeGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatAttributeGroupCountAggregateInputType | true
    _avg?: SeatAttributeGroupAvgAggregateInputType
    _sum?: SeatAttributeGroupSumAggregateInputType
    _min?: SeatAttributeGroupMinAggregateInputType
    _max?: SeatAttributeGroupMaxAggregateInputType
  }

  export type SeatAttributeGroupGroupByOutputType = {
    id: bigint
    storeId: bigint
    name: string
    selectionType: $Enums.SelectionType
    status: $Enums.AttributeStatus
    createdAt: Date
    updatedAt: Date
    _count: SeatAttributeGroupCountAggregateOutputType | null
    _avg: SeatAttributeGroupAvgAggregateOutputType | null
    _sum: SeatAttributeGroupSumAggregateOutputType | null
    _min: SeatAttributeGroupMinAggregateOutputType | null
    _max: SeatAttributeGroupMaxAggregateOutputType | null
  }

  type GetSeatAttributeGroupGroupByPayload<T extends SeatAttributeGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatAttributeGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatAttributeGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatAttributeGroupGroupByOutputType[P]>
            : GetScalarType<T[P], SeatAttributeGroupGroupByOutputType[P]>
        }
      >
    >


  export type SeatAttributeGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    selectionType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    attributes?: boolean | SeatAttributeGroup$attributesArgs<ExtArgs>
    _count?: boolean | SeatAttributeGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatAttributeGroup"]>

  export type SeatAttributeGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    selectionType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatAttributeGroup"]>

  export type SeatAttributeGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    selectionType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatAttributeGroup"]>

  export type SeatAttributeGroupSelectScalar = {
    id?: boolean
    storeId?: boolean
    name?: boolean
    selectionType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeatAttributeGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "name" | "selectionType" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["seatAttributeGroup"]>
  export type SeatAttributeGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    attributes?: boolean | SeatAttributeGroup$attributesArgs<ExtArgs>
    _count?: boolean | SeatAttributeGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeatAttributeGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type SeatAttributeGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $SeatAttributeGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeatAttributeGroup"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      attributes: Prisma.$SeatAttributePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      storeId: bigint
      name: string
      selectionType: $Enums.SelectionType
      status: $Enums.AttributeStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seatAttributeGroup"]>
    composites: {}
  }

  type SeatAttributeGroupGetPayload<S extends boolean | null | undefined | SeatAttributeGroupDefaultArgs> = $Result.GetResult<Prisma.$SeatAttributeGroupPayload, S>

  type SeatAttributeGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeatAttributeGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeatAttributeGroupCountAggregateInputType | true
    }

  export interface SeatAttributeGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeatAttributeGroup'], meta: { name: 'SeatAttributeGroup' } }
    /**
     * Find zero or one SeatAttributeGroup that matches the filter.
     * @param {SeatAttributeGroupFindUniqueArgs} args - Arguments to find a SeatAttributeGroup
     * @example
     * // Get one SeatAttributeGroup
     * const seatAttributeGroup = await prisma.seatAttributeGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatAttributeGroupFindUniqueArgs>(args: SelectSubset<T, SeatAttributeGroupFindUniqueArgs<ExtArgs>>): Prisma__SeatAttributeGroupClient<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeatAttributeGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeatAttributeGroupFindUniqueOrThrowArgs} args - Arguments to find a SeatAttributeGroup
     * @example
     * // Get one SeatAttributeGroup
     * const seatAttributeGroup = await prisma.seatAttributeGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatAttributeGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatAttributeGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatAttributeGroupClient<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeatAttributeGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeGroupFindFirstArgs} args - Arguments to find a SeatAttributeGroup
     * @example
     * // Get one SeatAttributeGroup
     * const seatAttributeGroup = await prisma.seatAttributeGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatAttributeGroupFindFirstArgs>(args?: SelectSubset<T, SeatAttributeGroupFindFirstArgs<ExtArgs>>): Prisma__SeatAttributeGroupClient<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeatAttributeGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeGroupFindFirstOrThrowArgs} args - Arguments to find a SeatAttributeGroup
     * @example
     * // Get one SeatAttributeGroup
     * const seatAttributeGroup = await prisma.seatAttributeGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatAttributeGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatAttributeGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatAttributeGroupClient<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeatAttributeGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeatAttributeGroups
     * const seatAttributeGroups = await prisma.seatAttributeGroup.findMany()
     * 
     * // Get first 10 SeatAttributeGroups
     * const seatAttributeGroups = await prisma.seatAttributeGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seatAttributeGroupWithIdOnly = await prisma.seatAttributeGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeatAttributeGroupFindManyArgs>(args?: SelectSubset<T, SeatAttributeGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeatAttributeGroup.
     * @param {SeatAttributeGroupCreateArgs} args - Arguments to create a SeatAttributeGroup.
     * @example
     * // Create one SeatAttributeGroup
     * const SeatAttributeGroup = await prisma.seatAttributeGroup.create({
     *   data: {
     *     // ... data to create a SeatAttributeGroup
     *   }
     * })
     * 
     */
    create<T extends SeatAttributeGroupCreateArgs>(args: SelectSubset<T, SeatAttributeGroupCreateArgs<ExtArgs>>): Prisma__SeatAttributeGroupClient<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeatAttributeGroups.
     * @param {SeatAttributeGroupCreateManyArgs} args - Arguments to create many SeatAttributeGroups.
     * @example
     * // Create many SeatAttributeGroups
     * const seatAttributeGroup = await prisma.seatAttributeGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatAttributeGroupCreateManyArgs>(args?: SelectSubset<T, SeatAttributeGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeatAttributeGroups and returns the data saved in the database.
     * @param {SeatAttributeGroupCreateManyAndReturnArgs} args - Arguments to create many SeatAttributeGroups.
     * @example
     * // Create many SeatAttributeGroups
     * const seatAttributeGroup = await prisma.seatAttributeGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeatAttributeGroups and only return the `id`
     * const seatAttributeGroupWithIdOnly = await prisma.seatAttributeGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeatAttributeGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, SeatAttributeGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SeatAttributeGroup.
     * @param {SeatAttributeGroupDeleteArgs} args - Arguments to delete one SeatAttributeGroup.
     * @example
     * // Delete one SeatAttributeGroup
     * const SeatAttributeGroup = await prisma.seatAttributeGroup.delete({
     *   where: {
     *     // ... filter to delete one SeatAttributeGroup
     *   }
     * })
     * 
     */
    delete<T extends SeatAttributeGroupDeleteArgs>(args: SelectSubset<T, SeatAttributeGroupDeleteArgs<ExtArgs>>): Prisma__SeatAttributeGroupClient<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeatAttributeGroup.
     * @param {SeatAttributeGroupUpdateArgs} args - Arguments to update one SeatAttributeGroup.
     * @example
     * // Update one SeatAttributeGroup
     * const seatAttributeGroup = await prisma.seatAttributeGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatAttributeGroupUpdateArgs>(args: SelectSubset<T, SeatAttributeGroupUpdateArgs<ExtArgs>>): Prisma__SeatAttributeGroupClient<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeatAttributeGroups.
     * @param {SeatAttributeGroupDeleteManyArgs} args - Arguments to filter SeatAttributeGroups to delete.
     * @example
     * // Delete a few SeatAttributeGroups
     * const { count } = await prisma.seatAttributeGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatAttributeGroupDeleteManyArgs>(args?: SelectSubset<T, SeatAttributeGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeatAttributeGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeatAttributeGroups
     * const seatAttributeGroup = await prisma.seatAttributeGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatAttributeGroupUpdateManyArgs>(args: SelectSubset<T, SeatAttributeGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeatAttributeGroups and returns the data updated in the database.
     * @param {SeatAttributeGroupUpdateManyAndReturnArgs} args - Arguments to update many SeatAttributeGroups.
     * @example
     * // Update many SeatAttributeGroups
     * const seatAttributeGroup = await prisma.seatAttributeGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SeatAttributeGroups and only return the `id`
     * const seatAttributeGroupWithIdOnly = await prisma.seatAttributeGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeatAttributeGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, SeatAttributeGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SeatAttributeGroup.
     * @param {SeatAttributeGroupUpsertArgs} args - Arguments to update or create a SeatAttributeGroup.
     * @example
     * // Update or create a SeatAttributeGroup
     * const seatAttributeGroup = await prisma.seatAttributeGroup.upsert({
     *   create: {
     *     // ... data to create a SeatAttributeGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeatAttributeGroup we want to update
     *   }
     * })
     */
    upsert<T extends SeatAttributeGroupUpsertArgs>(args: SelectSubset<T, SeatAttributeGroupUpsertArgs<ExtArgs>>): Prisma__SeatAttributeGroupClient<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeatAttributeGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeGroupCountArgs} args - Arguments to filter SeatAttributeGroups to count.
     * @example
     * // Count the number of SeatAttributeGroups
     * const count = await prisma.seatAttributeGroup.count({
     *   where: {
     *     // ... the filter for the SeatAttributeGroups we want to count
     *   }
     * })
    **/
    count<T extends SeatAttributeGroupCountArgs>(
      args?: Subset<T, SeatAttributeGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatAttributeGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeatAttributeGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatAttributeGroupAggregateArgs>(args: Subset<T, SeatAttributeGroupAggregateArgs>): Prisma.PrismaPromise<GetSeatAttributeGroupAggregateType<T>>

    /**
     * Group by SeatAttributeGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatAttributeGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatAttributeGroupGroupByArgs['orderBy'] }
        : { orderBy?: SeatAttributeGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatAttributeGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatAttributeGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeatAttributeGroup model
   */
  readonly fields: SeatAttributeGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeatAttributeGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatAttributeGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attributes<T extends SeatAttributeGroup$attributesArgs<ExtArgs> = {}>(args?: Subset<T, SeatAttributeGroup$attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeatAttributeGroup model
   */
  interface SeatAttributeGroupFieldRefs {
    readonly id: FieldRef<"SeatAttributeGroup", 'BigInt'>
    readonly storeId: FieldRef<"SeatAttributeGroup", 'BigInt'>
    readonly name: FieldRef<"SeatAttributeGroup", 'String'>
    readonly selectionType: FieldRef<"SeatAttributeGroup", 'SelectionType'>
    readonly status: FieldRef<"SeatAttributeGroup", 'AttributeStatus'>
    readonly createdAt: FieldRef<"SeatAttributeGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"SeatAttributeGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeatAttributeGroup findUnique
   */
  export type SeatAttributeGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeGroup to fetch.
     */
    where: SeatAttributeGroupWhereUniqueInput
  }

  /**
   * SeatAttributeGroup findUniqueOrThrow
   */
  export type SeatAttributeGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeGroup to fetch.
     */
    where: SeatAttributeGroupWhereUniqueInput
  }

  /**
   * SeatAttributeGroup findFirst
   */
  export type SeatAttributeGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeGroup to fetch.
     */
    where?: SeatAttributeGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributeGroups to fetch.
     */
    orderBy?: SeatAttributeGroupOrderByWithRelationInput | SeatAttributeGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatAttributeGroups.
     */
    cursor?: SeatAttributeGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributeGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributeGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatAttributeGroups.
     */
    distinct?: SeatAttributeGroupScalarFieldEnum | SeatAttributeGroupScalarFieldEnum[]
  }

  /**
   * SeatAttributeGroup findFirstOrThrow
   */
  export type SeatAttributeGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeGroup to fetch.
     */
    where?: SeatAttributeGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributeGroups to fetch.
     */
    orderBy?: SeatAttributeGroupOrderByWithRelationInput | SeatAttributeGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatAttributeGroups.
     */
    cursor?: SeatAttributeGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributeGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributeGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatAttributeGroups.
     */
    distinct?: SeatAttributeGroupScalarFieldEnum | SeatAttributeGroupScalarFieldEnum[]
  }

  /**
   * SeatAttributeGroup findMany
   */
  export type SeatAttributeGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeGroups to fetch.
     */
    where?: SeatAttributeGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributeGroups to fetch.
     */
    orderBy?: SeatAttributeGroupOrderByWithRelationInput | SeatAttributeGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeatAttributeGroups.
     */
    cursor?: SeatAttributeGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributeGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributeGroups.
     */
    skip?: number
    distinct?: SeatAttributeGroupScalarFieldEnum | SeatAttributeGroupScalarFieldEnum[]
  }

  /**
   * SeatAttributeGroup create
   */
  export type SeatAttributeGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a SeatAttributeGroup.
     */
    data: XOR<SeatAttributeGroupCreateInput, SeatAttributeGroupUncheckedCreateInput>
  }

  /**
   * SeatAttributeGroup createMany
   */
  export type SeatAttributeGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeatAttributeGroups.
     */
    data: SeatAttributeGroupCreateManyInput | SeatAttributeGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeatAttributeGroup createManyAndReturn
   */
  export type SeatAttributeGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * The data used to create many SeatAttributeGroups.
     */
    data: SeatAttributeGroupCreateManyInput | SeatAttributeGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeatAttributeGroup update
   */
  export type SeatAttributeGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a SeatAttributeGroup.
     */
    data: XOR<SeatAttributeGroupUpdateInput, SeatAttributeGroupUncheckedUpdateInput>
    /**
     * Choose, which SeatAttributeGroup to update.
     */
    where: SeatAttributeGroupWhereUniqueInput
  }

  /**
   * SeatAttributeGroup updateMany
   */
  export type SeatAttributeGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeatAttributeGroups.
     */
    data: XOR<SeatAttributeGroupUpdateManyMutationInput, SeatAttributeGroupUncheckedUpdateManyInput>
    /**
     * Filter which SeatAttributeGroups to update
     */
    where?: SeatAttributeGroupWhereInput
    /**
     * Limit how many SeatAttributeGroups to update.
     */
    limit?: number
  }

  /**
   * SeatAttributeGroup updateManyAndReturn
   */
  export type SeatAttributeGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * The data used to update SeatAttributeGroups.
     */
    data: XOR<SeatAttributeGroupUpdateManyMutationInput, SeatAttributeGroupUncheckedUpdateManyInput>
    /**
     * Filter which SeatAttributeGroups to update
     */
    where?: SeatAttributeGroupWhereInput
    /**
     * Limit how many SeatAttributeGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeatAttributeGroup upsert
   */
  export type SeatAttributeGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the SeatAttributeGroup to update in case it exists.
     */
    where: SeatAttributeGroupWhereUniqueInput
    /**
     * In case the SeatAttributeGroup found by the `where` argument doesn't exist, create a new SeatAttributeGroup with this data.
     */
    create: XOR<SeatAttributeGroupCreateInput, SeatAttributeGroupUncheckedCreateInput>
    /**
     * In case the SeatAttributeGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatAttributeGroupUpdateInput, SeatAttributeGroupUncheckedUpdateInput>
  }

  /**
   * SeatAttributeGroup delete
   */
  export type SeatAttributeGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
    /**
     * Filter which SeatAttributeGroup to delete.
     */
    where: SeatAttributeGroupWhereUniqueInput
  }

  /**
   * SeatAttributeGroup deleteMany
   */
  export type SeatAttributeGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatAttributeGroups to delete
     */
    where?: SeatAttributeGroupWhereInput
    /**
     * Limit how many SeatAttributeGroups to delete.
     */
    limit?: number
  }

  /**
   * SeatAttributeGroup.attributes
   */
  export type SeatAttributeGroup$attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    where?: SeatAttributeWhereInput
    orderBy?: SeatAttributeOrderByWithRelationInput | SeatAttributeOrderByWithRelationInput[]
    cursor?: SeatAttributeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatAttributeScalarFieldEnum | SeatAttributeScalarFieldEnum[]
  }

  /**
   * SeatAttributeGroup without action
   */
  export type SeatAttributeGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeGroup
     */
    select?: SeatAttributeGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeGroup
     */
    omit?: SeatAttributeGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeGroupInclude<ExtArgs> | null
  }


  /**
   * Model SeatAttribute
   */

  export type AggregateSeatAttribute = {
    _count: SeatAttributeCountAggregateOutputType | null
    _avg: SeatAttributeAvgAggregateOutputType | null
    _sum: SeatAttributeSumAggregateOutputType | null
    _min: SeatAttributeMinAggregateOutputType | null
    _max: SeatAttributeMaxAggregateOutputType | null
  }

  export type SeatAttributeAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
    groupId: number | null
  }

  export type SeatAttributeSumAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    groupId: bigint | null
  }

  export type SeatAttributeMinAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    groupId: bigint | null
    name: string | null
    status: $Enums.AttributeStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatAttributeMaxAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    groupId: bigint | null
    name: string | null
    status: $Enums.AttributeStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatAttributeCountAggregateOutputType = {
    id: number
    storeId: number
    groupId: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeatAttributeAvgAggregateInputType = {
    id?: true
    storeId?: true
    groupId?: true
  }

  export type SeatAttributeSumAggregateInputType = {
    id?: true
    storeId?: true
    groupId?: true
  }

  export type SeatAttributeMinAggregateInputType = {
    id?: true
    storeId?: true
    groupId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatAttributeMaxAggregateInputType = {
    id?: true
    storeId?: true
    groupId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatAttributeCountAggregateInputType = {
    id?: true
    storeId?: true
    groupId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeatAttributeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatAttribute to aggregate.
     */
    where?: SeatAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributes to fetch.
     */
    orderBy?: SeatAttributeOrderByWithRelationInput | SeatAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeatAttributes
    **/
    _count?: true | SeatAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatAttributeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatAttributeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatAttributeMaxAggregateInputType
  }

  export type GetSeatAttributeAggregateType<T extends SeatAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateSeatAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeatAttribute[P]>
      : GetScalarType<T[P], AggregateSeatAttribute[P]>
  }




  export type SeatAttributeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatAttributeWhereInput
    orderBy?: SeatAttributeOrderByWithAggregationInput | SeatAttributeOrderByWithAggregationInput[]
    by: SeatAttributeScalarFieldEnum[] | SeatAttributeScalarFieldEnum
    having?: SeatAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatAttributeCountAggregateInputType | true
    _avg?: SeatAttributeAvgAggregateInputType
    _sum?: SeatAttributeSumAggregateInputType
    _min?: SeatAttributeMinAggregateInputType
    _max?: SeatAttributeMaxAggregateInputType
  }

  export type SeatAttributeGroupByOutputType = {
    id: bigint
    storeId: bigint
    groupId: bigint
    name: string
    status: $Enums.AttributeStatus
    createdAt: Date
    updatedAt: Date
    _count: SeatAttributeCountAggregateOutputType | null
    _avg: SeatAttributeAvgAggregateOutputType | null
    _sum: SeatAttributeSumAggregateOutputType | null
    _min: SeatAttributeMinAggregateOutputType | null
    _max: SeatAttributeMaxAggregateOutputType | null
  }

  type GetSeatAttributeGroupByPayload<T extends SeatAttributeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], SeatAttributeGroupByOutputType[P]>
        }
      >
    >


  export type SeatAttributeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    groupId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    group?: boolean | SeatAttributeGroupDefaultArgs<ExtArgs>
    assignments?: boolean | SeatAttribute$assignmentsArgs<ExtArgs>
    _count?: boolean | SeatAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatAttribute"]>

  export type SeatAttributeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    groupId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    group?: boolean | SeatAttributeGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatAttribute"]>

  export type SeatAttributeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    groupId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    group?: boolean | SeatAttributeGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatAttribute"]>

  export type SeatAttributeSelectScalar = {
    id?: boolean
    storeId?: boolean
    groupId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeatAttributeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "groupId" | "name" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["seatAttribute"]>
  export type SeatAttributeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    group?: boolean | SeatAttributeGroupDefaultArgs<ExtArgs>
    assignments?: boolean | SeatAttribute$assignmentsArgs<ExtArgs>
    _count?: boolean | SeatAttributeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeatAttributeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    group?: boolean | SeatAttributeGroupDefaultArgs<ExtArgs>
  }
  export type SeatAttributeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    group?: boolean | SeatAttributeGroupDefaultArgs<ExtArgs>
  }

  export type $SeatAttributePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeatAttribute"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      group: Prisma.$SeatAttributeGroupPayload<ExtArgs>
      assignments: Prisma.$SeatAttributeAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      storeId: bigint
      groupId: bigint
      name: string
      status: $Enums.AttributeStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seatAttribute"]>
    composites: {}
  }

  type SeatAttributeGetPayload<S extends boolean | null | undefined | SeatAttributeDefaultArgs> = $Result.GetResult<Prisma.$SeatAttributePayload, S>

  type SeatAttributeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeatAttributeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeatAttributeCountAggregateInputType | true
    }

  export interface SeatAttributeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeatAttribute'], meta: { name: 'SeatAttribute' } }
    /**
     * Find zero or one SeatAttribute that matches the filter.
     * @param {SeatAttributeFindUniqueArgs} args - Arguments to find a SeatAttribute
     * @example
     * // Get one SeatAttribute
     * const seatAttribute = await prisma.seatAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatAttributeFindUniqueArgs>(args: SelectSubset<T, SeatAttributeFindUniqueArgs<ExtArgs>>): Prisma__SeatAttributeClient<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeatAttribute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeatAttributeFindUniqueOrThrowArgs} args - Arguments to find a SeatAttribute
     * @example
     * // Get one SeatAttribute
     * const seatAttribute = await prisma.seatAttribute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatAttributeFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatAttributeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatAttributeClient<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeatAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeFindFirstArgs} args - Arguments to find a SeatAttribute
     * @example
     * // Get one SeatAttribute
     * const seatAttribute = await prisma.seatAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatAttributeFindFirstArgs>(args?: SelectSubset<T, SeatAttributeFindFirstArgs<ExtArgs>>): Prisma__SeatAttributeClient<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeatAttribute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeFindFirstOrThrowArgs} args - Arguments to find a SeatAttribute
     * @example
     * // Get one SeatAttribute
     * const seatAttribute = await prisma.seatAttribute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatAttributeFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatAttributeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatAttributeClient<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeatAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeatAttributes
     * const seatAttributes = await prisma.seatAttribute.findMany()
     * 
     * // Get first 10 SeatAttributes
     * const seatAttributes = await prisma.seatAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seatAttributeWithIdOnly = await prisma.seatAttribute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeatAttributeFindManyArgs>(args?: SelectSubset<T, SeatAttributeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeatAttribute.
     * @param {SeatAttributeCreateArgs} args - Arguments to create a SeatAttribute.
     * @example
     * // Create one SeatAttribute
     * const SeatAttribute = await prisma.seatAttribute.create({
     *   data: {
     *     // ... data to create a SeatAttribute
     *   }
     * })
     * 
     */
    create<T extends SeatAttributeCreateArgs>(args: SelectSubset<T, SeatAttributeCreateArgs<ExtArgs>>): Prisma__SeatAttributeClient<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeatAttributes.
     * @param {SeatAttributeCreateManyArgs} args - Arguments to create many SeatAttributes.
     * @example
     * // Create many SeatAttributes
     * const seatAttribute = await prisma.seatAttribute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatAttributeCreateManyArgs>(args?: SelectSubset<T, SeatAttributeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeatAttributes and returns the data saved in the database.
     * @param {SeatAttributeCreateManyAndReturnArgs} args - Arguments to create many SeatAttributes.
     * @example
     * // Create many SeatAttributes
     * const seatAttribute = await prisma.seatAttribute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeatAttributes and only return the `id`
     * const seatAttributeWithIdOnly = await prisma.seatAttribute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeatAttributeCreateManyAndReturnArgs>(args?: SelectSubset<T, SeatAttributeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SeatAttribute.
     * @param {SeatAttributeDeleteArgs} args - Arguments to delete one SeatAttribute.
     * @example
     * // Delete one SeatAttribute
     * const SeatAttribute = await prisma.seatAttribute.delete({
     *   where: {
     *     // ... filter to delete one SeatAttribute
     *   }
     * })
     * 
     */
    delete<T extends SeatAttributeDeleteArgs>(args: SelectSubset<T, SeatAttributeDeleteArgs<ExtArgs>>): Prisma__SeatAttributeClient<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeatAttribute.
     * @param {SeatAttributeUpdateArgs} args - Arguments to update one SeatAttribute.
     * @example
     * // Update one SeatAttribute
     * const seatAttribute = await prisma.seatAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatAttributeUpdateArgs>(args: SelectSubset<T, SeatAttributeUpdateArgs<ExtArgs>>): Prisma__SeatAttributeClient<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeatAttributes.
     * @param {SeatAttributeDeleteManyArgs} args - Arguments to filter SeatAttributes to delete.
     * @example
     * // Delete a few SeatAttributes
     * const { count } = await prisma.seatAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatAttributeDeleteManyArgs>(args?: SelectSubset<T, SeatAttributeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeatAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeatAttributes
     * const seatAttribute = await prisma.seatAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatAttributeUpdateManyArgs>(args: SelectSubset<T, SeatAttributeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeatAttributes and returns the data updated in the database.
     * @param {SeatAttributeUpdateManyAndReturnArgs} args - Arguments to update many SeatAttributes.
     * @example
     * // Update many SeatAttributes
     * const seatAttribute = await prisma.seatAttribute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SeatAttributes and only return the `id`
     * const seatAttributeWithIdOnly = await prisma.seatAttribute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeatAttributeUpdateManyAndReturnArgs>(args: SelectSubset<T, SeatAttributeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SeatAttribute.
     * @param {SeatAttributeUpsertArgs} args - Arguments to update or create a SeatAttribute.
     * @example
     * // Update or create a SeatAttribute
     * const seatAttribute = await prisma.seatAttribute.upsert({
     *   create: {
     *     // ... data to create a SeatAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeatAttribute we want to update
     *   }
     * })
     */
    upsert<T extends SeatAttributeUpsertArgs>(args: SelectSubset<T, SeatAttributeUpsertArgs<ExtArgs>>): Prisma__SeatAttributeClient<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeatAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeCountArgs} args - Arguments to filter SeatAttributes to count.
     * @example
     * // Count the number of SeatAttributes
     * const count = await prisma.seatAttribute.count({
     *   where: {
     *     // ... the filter for the SeatAttributes we want to count
     *   }
     * })
    **/
    count<T extends SeatAttributeCountArgs>(
      args?: Subset<T, SeatAttributeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeatAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatAttributeAggregateArgs>(args: Subset<T, SeatAttributeAggregateArgs>): Prisma.PrismaPromise<GetSeatAttributeAggregateType<T>>

    /**
     * Group by SeatAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatAttributeGroupByArgs['orderBy'] }
        : { orderBy?: SeatAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatAttributeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeatAttribute model
   */
  readonly fields: SeatAttributeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeatAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatAttributeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends SeatAttributeGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeatAttributeGroupDefaultArgs<ExtArgs>>): Prisma__SeatAttributeGroupClient<$Result.GetResult<Prisma.$SeatAttributeGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignments<T extends SeatAttribute$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, SeatAttribute$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeatAttribute model
   */
  interface SeatAttributeFieldRefs {
    readonly id: FieldRef<"SeatAttribute", 'BigInt'>
    readonly storeId: FieldRef<"SeatAttribute", 'BigInt'>
    readonly groupId: FieldRef<"SeatAttribute", 'BigInt'>
    readonly name: FieldRef<"SeatAttribute", 'String'>
    readonly status: FieldRef<"SeatAttribute", 'AttributeStatus'>
    readonly createdAt: FieldRef<"SeatAttribute", 'DateTime'>
    readonly updatedAt: FieldRef<"SeatAttribute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeatAttribute findUnique
   */
  export type SeatAttributeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttribute to fetch.
     */
    where: SeatAttributeWhereUniqueInput
  }

  /**
   * SeatAttribute findUniqueOrThrow
   */
  export type SeatAttributeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttribute to fetch.
     */
    where: SeatAttributeWhereUniqueInput
  }

  /**
   * SeatAttribute findFirst
   */
  export type SeatAttributeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttribute to fetch.
     */
    where?: SeatAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributes to fetch.
     */
    orderBy?: SeatAttributeOrderByWithRelationInput | SeatAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatAttributes.
     */
    cursor?: SeatAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatAttributes.
     */
    distinct?: SeatAttributeScalarFieldEnum | SeatAttributeScalarFieldEnum[]
  }

  /**
   * SeatAttribute findFirstOrThrow
   */
  export type SeatAttributeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttribute to fetch.
     */
    where?: SeatAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributes to fetch.
     */
    orderBy?: SeatAttributeOrderByWithRelationInput | SeatAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatAttributes.
     */
    cursor?: SeatAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatAttributes.
     */
    distinct?: SeatAttributeScalarFieldEnum | SeatAttributeScalarFieldEnum[]
  }

  /**
   * SeatAttribute findMany
   */
  export type SeatAttributeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributes to fetch.
     */
    where?: SeatAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributes to fetch.
     */
    orderBy?: SeatAttributeOrderByWithRelationInput | SeatAttributeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeatAttributes.
     */
    cursor?: SeatAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributes.
     */
    skip?: number
    distinct?: SeatAttributeScalarFieldEnum | SeatAttributeScalarFieldEnum[]
  }

  /**
   * SeatAttribute create
   */
  export type SeatAttributeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    /**
     * The data needed to create a SeatAttribute.
     */
    data: XOR<SeatAttributeCreateInput, SeatAttributeUncheckedCreateInput>
  }

  /**
   * SeatAttribute createMany
   */
  export type SeatAttributeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeatAttributes.
     */
    data: SeatAttributeCreateManyInput | SeatAttributeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeatAttribute createManyAndReturn
   */
  export type SeatAttributeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * The data used to create many SeatAttributes.
     */
    data: SeatAttributeCreateManyInput | SeatAttributeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeatAttribute update
   */
  export type SeatAttributeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    /**
     * The data needed to update a SeatAttribute.
     */
    data: XOR<SeatAttributeUpdateInput, SeatAttributeUncheckedUpdateInput>
    /**
     * Choose, which SeatAttribute to update.
     */
    where: SeatAttributeWhereUniqueInput
  }

  /**
   * SeatAttribute updateMany
   */
  export type SeatAttributeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeatAttributes.
     */
    data: XOR<SeatAttributeUpdateManyMutationInput, SeatAttributeUncheckedUpdateManyInput>
    /**
     * Filter which SeatAttributes to update
     */
    where?: SeatAttributeWhereInput
    /**
     * Limit how many SeatAttributes to update.
     */
    limit?: number
  }

  /**
   * SeatAttribute updateManyAndReturn
   */
  export type SeatAttributeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * The data used to update SeatAttributes.
     */
    data: XOR<SeatAttributeUpdateManyMutationInput, SeatAttributeUncheckedUpdateManyInput>
    /**
     * Filter which SeatAttributes to update
     */
    where?: SeatAttributeWhereInput
    /**
     * Limit how many SeatAttributes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeatAttribute upsert
   */
  export type SeatAttributeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    /**
     * The filter to search for the SeatAttribute to update in case it exists.
     */
    where: SeatAttributeWhereUniqueInput
    /**
     * In case the SeatAttribute found by the `where` argument doesn't exist, create a new SeatAttribute with this data.
     */
    create: XOR<SeatAttributeCreateInput, SeatAttributeUncheckedCreateInput>
    /**
     * In case the SeatAttribute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatAttributeUpdateInput, SeatAttributeUncheckedUpdateInput>
  }

  /**
   * SeatAttribute delete
   */
  export type SeatAttributeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
    /**
     * Filter which SeatAttribute to delete.
     */
    where: SeatAttributeWhereUniqueInput
  }

  /**
   * SeatAttribute deleteMany
   */
  export type SeatAttributeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatAttributes to delete
     */
    where?: SeatAttributeWhereInput
    /**
     * Limit how many SeatAttributes to delete.
     */
    limit?: number
  }

  /**
   * SeatAttribute.assignments
   */
  export type SeatAttribute$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    where?: SeatAttributeAssignmentWhereInput
    orderBy?: SeatAttributeAssignmentOrderByWithRelationInput | SeatAttributeAssignmentOrderByWithRelationInput[]
    cursor?: SeatAttributeAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatAttributeAssignmentScalarFieldEnum | SeatAttributeAssignmentScalarFieldEnum[]
  }

  /**
   * SeatAttribute without action
   */
  export type SeatAttributeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttribute
     */
    select?: SeatAttributeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttribute
     */
    omit?: SeatAttributeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeInclude<ExtArgs> | null
  }


  /**
   * Model SeatAttributeAssignment
   */

  export type AggregateSeatAttributeAssignment = {
    _count: SeatAttributeAssignmentCountAggregateOutputType | null
    _avg: SeatAttributeAssignmentAvgAggregateOutputType | null
    _sum: SeatAttributeAssignmentSumAggregateOutputType | null
    _min: SeatAttributeAssignmentMinAggregateOutputType | null
    _max: SeatAttributeAssignmentMaxAggregateOutputType | null
  }

  export type SeatAttributeAssignmentAvgAggregateOutputType = {
    seatId: number | null
    attributeId: number | null
  }

  export type SeatAttributeAssignmentSumAggregateOutputType = {
    seatId: bigint | null
    attributeId: bigint | null
  }

  export type SeatAttributeAssignmentMinAggregateOutputType = {
    seatId: bigint | null
    attributeId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatAttributeAssignmentMaxAggregateOutputType = {
    seatId: bigint | null
    attributeId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatAttributeAssignmentCountAggregateOutputType = {
    seatId: number
    attributeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeatAttributeAssignmentAvgAggregateInputType = {
    seatId?: true
    attributeId?: true
  }

  export type SeatAttributeAssignmentSumAggregateInputType = {
    seatId?: true
    attributeId?: true
  }

  export type SeatAttributeAssignmentMinAggregateInputType = {
    seatId?: true
    attributeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatAttributeAssignmentMaxAggregateInputType = {
    seatId?: true
    attributeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatAttributeAssignmentCountAggregateInputType = {
    seatId?: true
    attributeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeatAttributeAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatAttributeAssignment to aggregate.
     */
    where?: SeatAttributeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributeAssignments to fetch.
     */
    orderBy?: SeatAttributeAssignmentOrderByWithRelationInput | SeatAttributeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatAttributeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributeAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeatAttributeAssignments
    **/
    _count?: true | SeatAttributeAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatAttributeAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatAttributeAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatAttributeAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatAttributeAssignmentMaxAggregateInputType
  }

  export type GetSeatAttributeAssignmentAggregateType<T extends SeatAttributeAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateSeatAttributeAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeatAttributeAssignment[P]>
      : GetScalarType<T[P], AggregateSeatAttributeAssignment[P]>
  }




  export type SeatAttributeAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatAttributeAssignmentWhereInput
    orderBy?: SeatAttributeAssignmentOrderByWithAggregationInput | SeatAttributeAssignmentOrderByWithAggregationInput[]
    by: SeatAttributeAssignmentScalarFieldEnum[] | SeatAttributeAssignmentScalarFieldEnum
    having?: SeatAttributeAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatAttributeAssignmentCountAggregateInputType | true
    _avg?: SeatAttributeAssignmentAvgAggregateInputType
    _sum?: SeatAttributeAssignmentSumAggregateInputType
    _min?: SeatAttributeAssignmentMinAggregateInputType
    _max?: SeatAttributeAssignmentMaxAggregateInputType
  }

  export type SeatAttributeAssignmentGroupByOutputType = {
    seatId: bigint
    attributeId: bigint
    createdAt: Date
    updatedAt: Date
    _count: SeatAttributeAssignmentCountAggregateOutputType | null
    _avg: SeatAttributeAssignmentAvgAggregateOutputType | null
    _sum: SeatAttributeAssignmentSumAggregateOutputType | null
    _min: SeatAttributeAssignmentMinAggregateOutputType | null
    _max: SeatAttributeAssignmentMaxAggregateOutputType | null
  }

  type GetSeatAttributeAssignmentGroupByPayload<T extends SeatAttributeAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatAttributeAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatAttributeAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatAttributeAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], SeatAttributeAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type SeatAttributeAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seatId?: boolean
    attributeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    attribute?: boolean | SeatAttributeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatAttributeAssignment"]>

  export type SeatAttributeAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seatId?: boolean
    attributeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    attribute?: boolean | SeatAttributeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatAttributeAssignment"]>

  export type SeatAttributeAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    seatId?: boolean
    attributeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    attribute?: boolean | SeatAttributeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatAttributeAssignment"]>

  export type SeatAttributeAssignmentSelectScalar = {
    seatId?: boolean
    attributeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeatAttributeAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"seatId" | "attributeId" | "createdAt" | "updatedAt", ExtArgs["result"]["seatAttributeAssignment"]>
  export type SeatAttributeAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    attribute?: boolean | SeatAttributeDefaultArgs<ExtArgs>
  }
  export type SeatAttributeAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    attribute?: boolean | SeatAttributeDefaultArgs<ExtArgs>
  }
  export type SeatAttributeAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    attribute?: boolean | SeatAttributeDefaultArgs<ExtArgs>
  }

  export type $SeatAttributeAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeatAttributeAssignment"
    objects: {
      seat: Prisma.$SeatPayload<ExtArgs>
      attribute: Prisma.$SeatAttributePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      seatId: bigint
      attributeId: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seatAttributeAssignment"]>
    composites: {}
  }

  type SeatAttributeAssignmentGetPayload<S extends boolean | null | undefined | SeatAttributeAssignmentDefaultArgs> = $Result.GetResult<Prisma.$SeatAttributeAssignmentPayload, S>

  type SeatAttributeAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeatAttributeAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeatAttributeAssignmentCountAggregateInputType | true
    }

  export interface SeatAttributeAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeatAttributeAssignment'], meta: { name: 'SeatAttributeAssignment' } }
    /**
     * Find zero or one SeatAttributeAssignment that matches the filter.
     * @param {SeatAttributeAssignmentFindUniqueArgs} args - Arguments to find a SeatAttributeAssignment
     * @example
     * // Get one SeatAttributeAssignment
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatAttributeAssignmentFindUniqueArgs>(args: SelectSubset<T, SeatAttributeAssignmentFindUniqueArgs<ExtArgs>>): Prisma__SeatAttributeAssignmentClient<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeatAttributeAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeatAttributeAssignmentFindUniqueOrThrowArgs} args - Arguments to find a SeatAttributeAssignment
     * @example
     * // Get one SeatAttributeAssignment
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatAttributeAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatAttributeAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatAttributeAssignmentClient<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeatAttributeAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeAssignmentFindFirstArgs} args - Arguments to find a SeatAttributeAssignment
     * @example
     * // Get one SeatAttributeAssignment
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatAttributeAssignmentFindFirstArgs>(args?: SelectSubset<T, SeatAttributeAssignmentFindFirstArgs<ExtArgs>>): Prisma__SeatAttributeAssignmentClient<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeatAttributeAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeAssignmentFindFirstOrThrowArgs} args - Arguments to find a SeatAttributeAssignment
     * @example
     * // Get one SeatAttributeAssignment
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatAttributeAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatAttributeAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatAttributeAssignmentClient<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeatAttributeAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeatAttributeAssignments
     * const seatAttributeAssignments = await prisma.seatAttributeAssignment.findMany()
     * 
     * // Get first 10 SeatAttributeAssignments
     * const seatAttributeAssignments = await prisma.seatAttributeAssignment.findMany({ take: 10 })
     * 
     * // Only select the `seatId`
     * const seatAttributeAssignmentWithSeatIdOnly = await prisma.seatAttributeAssignment.findMany({ select: { seatId: true } })
     * 
     */
    findMany<T extends SeatAttributeAssignmentFindManyArgs>(args?: SelectSubset<T, SeatAttributeAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeatAttributeAssignment.
     * @param {SeatAttributeAssignmentCreateArgs} args - Arguments to create a SeatAttributeAssignment.
     * @example
     * // Create one SeatAttributeAssignment
     * const SeatAttributeAssignment = await prisma.seatAttributeAssignment.create({
     *   data: {
     *     // ... data to create a SeatAttributeAssignment
     *   }
     * })
     * 
     */
    create<T extends SeatAttributeAssignmentCreateArgs>(args: SelectSubset<T, SeatAttributeAssignmentCreateArgs<ExtArgs>>): Prisma__SeatAttributeAssignmentClient<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeatAttributeAssignments.
     * @param {SeatAttributeAssignmentCreateManyArgs} args - Arguments to create many SeatAttributeAssignments.
     * @example
     * // Create many SeatAttributeAssignments
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatAttributeAssignmentCreateManyArgs>(args?: SelectSubset<T, SeatAttributeAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeatAttributeAssignments and returns the data saved in the database.
     * @param {SeatAttributeAssignmentCreateManyAndReturnArgs} args - Arguments to create many SeatAttributeAssignments.
     * @example
     * // Create many SeatAttributeAssignments
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeatAttributeAssignments and only return the `seatId`
     * const seatAttributeAssignmentWithSeatIdOnly = await prisma.seatAttributeAssignment.createManyAndReturn({
     *   select: { seatId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeatAttributeAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, SeatAttributeAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SeatAttributeAssignment.
     * @param {SeatAttributeAssignmentDeleteArgs} args - Arguments to delete one SeatAttributeAssignment.
     * @example
     * // Delete one SeatAttributeAssignment
     * const SeatAttributeAssignment = await prisma.seatAttributeAssignment.delete({
     *   where: {
     *     // ... filter to delete one SeatAttributeAssignment
     *   }
     * })
     * 
     */
    delete<T extends SeatAttributeAssignmentDeleteArgs>(args: SelectSubset<T, SeatAttributeAssignmentDeleteArgs<ExtArgs>>): Prisma__SeatAttributeAssignmentClient<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeatAttributeAssignment.
     * @param {SeatAttributeAssignmentUpdateArgs} args - Arguments to update one SeatAttributeAssignment.
     * @example
     * // Update one SeatAttributeAssignment
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatAttributeAssignmentUpdateArgs>(args: SelectSubset<T, SeatAttributeAssignmentUpdateArgs<ExtArgs>>): Prisma__SeatAttributeAssignmentClient<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeatAttributeAssignments.
     * @param {SeatAttributeAssignmentDeleteManyArgs} args - Arguments to filter SeatAttributeAssignments to delete.
     * @example
     * // Delete a few SeatAttributeAssignments
     * const { count } = await prisma.seatAttributeAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatAttributeAssignmentDeleteManyArgs>(args?: SelectSubset<T, SeatAttributeAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeatAttributeAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeatAttributeAssignments
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatAttributeAssignmentUpdateManyArgs>(args: SelectSubset<T, SeatAttributeAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeatAttributeAssignments and returns the data updated in the database.
     * @param {SeatAttributeAssignmentUpdateManyAndReturnArgs} args - Arguments to update many SeatAttributeAssignments.
     * @example
     * // Update many SeatAttributeAssignments
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SeatAttributeAssignments and only return the `seatId`
     * const seatAttributeAssignmentWithSeatIdOnly = await prisma.seatAttributeAssignment.updateManyAndReturn({
     *   select: { seatId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeatAttributeAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, SeatAttributeAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SeatAttributeAssignment.
     * @param {SeatAttributeAssignmentUpsertArgs} args - Arguments to update or create a SeatAttributeAssignment.
     * @example
     * // Update or create a SeatAttributeAssignment
     * const seatAttributeAssignment = await prisma.seatAttributeAssignment.upsert({
     *   create: {
     *     // ... data to create a SeatAttributeAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeatAttributeAssignment we want to update
     *   }
     * })
     */
    upsert<T extends SeatAttributeAssignmentUpsertArgs>(args: SelectSubset<T, SeatAttributeAssignmentUpsertArgs<ExtArgs>>): Prisma__SeatAttributeAssignmentClient<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeatAttributeAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeAssignmentCountArgs} args - Arguments to filter SeatAttributeAssignments to count.
     * @example
     * // Count the number of SeatAttributeAssignments
     * const count = await prisma.seatAttributeAssignment.count({
     *   where: {
     *     // ... the filter for the SeatAttributeAssignments we want to count
     *   }
     * })
    **/
    count<T extends SeatAttributeAssignmentCountArgs>(
      args?: Subset<T, SeatAttributeAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatAttributeAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeatAttributeAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatAttributeAssignmentAggregateArgs>(args: Subset<T, SeatAttributeAssignmentAggregateArgs>): Prisma.PrismaPromise<GetSeatAttributeAssignmentAggregateType<T>>

    /**
     * Group by SeatAttributeAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAttributeAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatAttributeAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatAttributeAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: SeatAttributeAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatAttributeAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatAttributeAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeatAttributeAssignment model
   */
  readonly fields: SeatAttributeAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeatAttributeAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatAttributeAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seat<T extends SeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeatDefaultArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attribute<T extends SeatAttributeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeatAttributeDefaultArgs<ExtArgs>>): Prisma__SeatAttributeClient<$Result.GetResult<Prisma.$SeatAttributePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeatAttributeAssignment model
   */
  interface SeatAttributeAssignmentFieldRefs {
    readonly seatId: FieldRef<"SeatAttributeAssignment", 'BigInt'>
    readonly attributeId: FieldRef<"SeatAttributeAssignment", 'BigInt'>
    readonly createdAt: FieldRef<"SeatAttributeAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"SeatAttributeAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeatAttributeAssignment findUnique
   */
  export type SeatAttributeAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeAssignment to fetch.
     */
    where: SeatAttributeAssignmentWhereUniqueInput
  }

  /**
   * SeatAttributeAssignment findUniqueOrThrow
   */
  export type SeatAttributeAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeAssignment to fetch.
     */
    where: SeatAttributeAssignmentWhereUniqueInput
  }

  /**
   * SeatAttributeAssignment findFirst
   */
  export type SeatAttributeAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeAssignment to fetch.
     */
    where?: SeatAttributeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributeAssignments to fetch.
     */
    orderBy?: SeatAttributeAssignmentOrderByWithRelationInput | SeatAttributeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatAttributeAssignments.
     */
    cursor?: SeatAttributeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributeAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatAttributeAssignments.
     */
    distinct?: SeatAttributeAssignmentScalarFieldEnum | SeatAttributeAssignmentScalarFieldEnum[]
  }

  /**
   * SeatAttributeAssignment findFirstOrThrow
   */
  export type SeatAttributeAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeAssignment to fetch.
     */
    where?: SeatAttributeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributeAssignments to fetch.
     */
    orderBy?: SeatAttributeAssignmentOrderByWithRelationInput | SeatAttributeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatAttributeAssignments.
     */
    cursor?: SeatAttributeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributeAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatAttributeAssignments.
     */
    distinct?: SeatAttributeAssignmentScalarFieldEnum | SeatAttributeAssignmentScalarFieldEnum[]
  }

  /**
   * SeatAttributeAssignment findMany
   */
  export type SeatAttributeAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which SeatAttributeAssignments to fetch.
     */
    where?: SeatAttributeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatAttributeAssignments to fetch.
     */
    orderBy?: SeatAttributeAssignmentOrderByWithRelationInput | SeatAttributeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeatAttributeAssignments.
     */
    cursor?: SeatAttributeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatAttributeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatAttributeAssignments.
     */
    skip?: number
    distinct?: SeatAttributeAssignmentScalarFieldEnum | SeatAttributeAssignmentScalarFieldEnum[]
  }

  /**
   * SeatAttributeAssignment create
   */
  export type SeatAttributeAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a SeatAttributeAssignment.
     */
    data: XOR<SeatAttributeAssignmentCreateInput, SeatAttributeAssignmentUncheckedCreateInput>
  }

  /**
   * SeatAttributeAssignment createMany
   */
  export type SeatAttributeAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeatAttributeAssignments.
     */
    data: SeatAttributeAssignmentCreateManyInput | SeatAttributeAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeatAttributeAssignment createManyAndReturn
   */
  export type SeatAttributeAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many SeatAttributeAssignments.
     */
    data: SeatAttributeAssignmentCreateManyInput | SeatAttributeAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeatAttributeAssignment update
   */
  export type SeatAttributeAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a SeatAttributeAssignment.
     */
    data: XOR<SeatAttributeAssignmentUpdateInput, SeatAttributeAssignmentUncheckedUpdateInput>
    /**
     * Choose, which SeatAttributeAssignment to update.
     */
    where: SeatAttributeAssignmentWhereUniqueInput
  }

  /**
   * SeatAttributeAssignment updateMany
   */
  export type SeatAttributeAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeatAttributeAssignments.
     */
    data: XOR<SeatAttributeAssignmentUpdateManyMutationInput, SeatAttributeAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which SeatAttributeAssignments to update
     */
    where?: SeatAttributeAssignmentWhereInput
    /**
     * Limit how many SeatAttributeAssignments to update.
     */
    limit?: number
  }

  /**
   * SeatAttributeAssignment updateManyAndReturn
   */
  export type SeatAttributeAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update SeatAttributeAssignments.
     */
    data: XOR<SeatAttributeAssignmentUpdateManyMutationInput, SeatAttributeAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which SeatAttributeAssignments to update
     */
    where?: SeatAttributeAssignmentWhereInput
    /**
     * Limit how many SeatAttributeAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeatAttributeAssignment upsert
   */
  export type SeatAttributeAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the SeatAttributeAssignment to update in case it exists.
     */
    where: SeatAttributeAssignmentWhereUniqueInput
    /**
     * In case the SeatAttributeAssignment found by the `where` argument doesn't exist, create a new SeatAttributeAssignment with this data.
     */
    create: XOR<SeatAttributeAssignmentCreateInput, SeatAttributeAssignmentUncheckedCreateInput>
    /**
     * In case the SeatAttributeAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatAttributeAssignmentUpdateInput, SeatAttributeAssignmentUncheckedUpdateInput>
  }

  /**
   * SeatAttributeAssignment delete
   */
  export type SeatAttributeAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    /**
     * Filter which SeatAttributeAssignment to delete.
     */
    where: SeatAttributeAssignmentWhereUniqueInput
  }

  /**
   * SeatAttributeAssignment deleteMany
   */
  export type SeatAttributeAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatAttributeAssignments to delete
     */
    where?: SeatAttributeAssignmentWhereInput
    /**
     * Limit how many SeatAttributeAssignments to delete.
     */
    limit?: number
  }

  /**
   * SeatAttributeAssignment without action
   */
  export type SeatAttributeAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Seat
   */

  export type AggregateSeat = {
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  export type SeatAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
    minCapacity: number | null
    maxCapacity: number | null
  }

  export type SeatSumAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    minCapacity: number | null
    maxCapacity: number | null
  }

  export type SeatMinAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    name: string | null
    minCapacity: number | null
    maxCapacity: number | null
    status: $Enums.SeatStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatMaxAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    name: string | null
    minCapacity: number | null
    maxCapacity: number | null
    status: $Enums.SeatStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeatCountAggregateOutputType = {
    id: number
    storeId: number
    name: number
    minCapacity: number
    maxCapacity: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeatAvgAggregateInputType = {
    id?: true
    storeId?: true
    minCapacity?: true
    maxCapacity?: true
  }

  export type SeatSumAggregateInputType = {
    id?: true
    storeId?: true
    minCapacity?: true
    maxCapacity?: true
  }

  export type SeatMinAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    minCapacity?: true
    maxCapacity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatMaxAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    minCapacity?: true
    maxCapacity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeatCountAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    minCapacity?: true
    maxCapacity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seat to aggregate.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seats
    **/
    _count?: true | SeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatMaxAggregateInputType
  }

  export type GetSeatAggregateType<T extends SeatAggregateArgs> = {
        [P in keyof T & keyof AggregateSeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeat[P]>
      : GetScalarType<T[P], AggregateSeat[P]>
  }




  export type SeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatWhereInput
    orderBy?: SeatOrderByWithAggregationInput | SeatOrderByWithAggregationInput[]
    by: SeatScalarFieldEnum[] | SeatScalarFieldEnum
    having?: SeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatCountAggregateInputType | true
    _avg?: SeatAvgAggregateInputType
    _sum?: SeatSumAggregateInputType
    _min?: SeatMinAggregateInputType
    _max?: SeatMaxAggregateInputType
  }

  export type SeatGroupByOutputType = {
    id: bigint
    storeId: bigint
    name: string
    minCapacity: number
    maxCapacity: number
    status: $Enums.SeatStatus
    createdAt: Date
    updatedAt: Date
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  type GetSeatGroupByPayload<T extends SeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatGroupByOutputType[P]>
            : GetScalarType<T[P], SeatGroupByOutputType[P]>
        }
      >
    >


  export type SeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    minCapacity?: boolean
    maxCapacity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    attributes?: boolean | Seat$attributesArgs<ExtArgs>
    layouts?: boolean | Seat$layoutsArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>

  export type SeatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    minCapacity?: boolean
    maxCapacity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>

  export type SeatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    minCapacity?: boolean
    maxCapacity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>

  export type SeatSelectScalar = {
    id?: boolean
    storeId?: boolean
    name?: boolean
    minCapacity?: boolean
    maxCapacity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "name" | "minCapacity" | "maxCapacity" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["seat"]>
  export type SeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    attributes?: boolean | Seat$attributesArgs<ExtArgs>
    layouts?: boolean | Seat$layoutsArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type SeatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $SeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seat"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      attributes: Prisma.$SeatAttributeAssignmentPayload<ExtArgs>[]
      layouts: Prisma.$LayoutSeatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      storeId: bigint
      name: string
      minCapacity: number
      maxCapacity: number
      status: $Enums.SeatStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seat"]>
    composites: {}
  }

  type SeatGetPayload<S extends boolean | null | undefined | SeatDefaultArgs> = $Result.GetResult<Prisma.$SeatPayload, S>

  type SeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeatCountAggregateInputType | true
    }

  export interface SeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seat'], meta: { name: 'Seat' } }
    /**
     * Find zero or one Seat that matches the filter.
     * @param {SeatFindUniqueArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatFindUniqueArgs>(args: SelectSubset<T, SeatFindUniqueArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeatFindUniqueOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindFirstArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatFindFirstArgs>(args?: SelectSubset<T, SeatFindFirstArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindFirstOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seats
     * const seats = await prisma.seat.findMany()
     * 
     * // Get first 10 Seats
     * const seats = await prisma.seat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seatWithIdOnly = await prisma.seat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeatFindManyArgs>(args?: SelectSubset<T, SeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seat.
     * @param {SeatCreateArgs} args - Arguments to create a Seat.
     * @example
     * // Create one Seat
     * const Seat = await prisma.seat.create({
     *   data: {
     *     // ... data to create a Seat
     *   }
     * })
     * 
     */
    create<T extends SeatCreateArgs>(args: SelectSubset<T, SeatCreateArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seats.
     * @param {SeatCreateManyArgs} args - Arguments to create many Seats.
     * @example
     * // Create many Seats
     * const seat = await prisma.seat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatCreateManyArgs>(args?: SelectSubset<T, SeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seats and returns the data saved in the database.
     * @param {SeatCreateManyAndReturnArgs} args - Arguments to create many Seats.
     * @example
     * // Create many Seats
     * const seat = await prisma.seat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seats and only return the `id`
     * const seatWithIdOnly = await prisma.seat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeatCreateManyAndReturnArgs>(args?: SelectSubset<T, SeatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Seat.
     * @param {SeatDeleteArgs} args - Arguments to delete one Seat.
     * @example
     * // Delete one Seat
     * const Seat = await prisma.seat.delete({
     *   where: {
     *     // ... filter to delete one Seat
     *   }
     * })
     * 
     */
    delete<T extends SeatDeleteArgs>(args: SelectSubset<T, SeatDeleteArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seat.
     * @param {SeatUpdateArgs} args - Arguments to update one Seat.
     * @example
     * // Update one Seat
     * const seat = await prisma.seat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatUpdateArgs>(args: SelectSubset<T, SeatUpdateArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seats.
     * @param {SeatDeleteManyArgs} args - Arguments to filter Seats to delete.
     * @example
     * // Delete a few Seats
     * const { count } = await prisma.seat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatDeleteManyArgs>(args?: SelectSubset<T, SeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seats
     * const seat = await prisma.seat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatUpdateManyArgs>(args: SelectSubset<T, SeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seats and returns the data updated in the database.
     * @param {SeatUpdateManyAndReturnArgs} args - Arguments to update many Seats.
     * @example
     * // Update many Seats
     * const seat = await prisma.seat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seats and only return the `id`
     * const seatWithIdOnly = await prisma.seat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeatUpdateManyAndReturnArgs>(args: SelectSubset<T, SeatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Seat.
     * @param {SeatUpsertArgs} args - Arguments to update or create a Seat.
     * @example
     * // Update or create a Seat
     * const seat = await prisma.seat.upsert({
     *   create: {
     *     // ... data to create a Seat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seat we want to update
     *   }
     * })
     */
    upsert<T extends SeatUpsertArgs>(args: SelectSubset<T, SeatUpsertArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatCountArgs} args - Arguments to filter Seats to count.
     * @example
     * // Count the number of Seats
     * const count = await prisma.seat.count({
     *   where: {
     *     // ... the filter for the Seats we want to count
     *   }
     * })
    **/
    count<T extends SeatCountArgs>(
      args?: Subset<T, SeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatAggregateArgs>(args: Subset<T, SeatAggregateArgs>): Prisma.PrismaPromise<GetSeatAggregateType<T>>

    /**
     * Group by Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatGroupByArgs['orderBy'] }
        : { orderBy?: SeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seat model
   */
  readonly fields: SeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attributes<T extends Seat$attributesArgs<ExtArgs> = {}>(args?: Subset<T, Seat$attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatAttributeAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    layouts<T extends Seat$layoutsArgs<ExtArgs> = {}>(args?: Subset<T, Seat$layoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seat model
   */
  interface SeatFieldRefs {
    readonly id: FieldRef<"Seat", 'BigInt'>
    readonly storeId: FieldRef<"Seat", 'BigInt'>
    readonly name: FieldRef<"Seat", 'String'>
    readonly minCapacity: FieldRef<"Seat", 'Int'>
    readonly maxCapacity: FieldRef<"Seat", 'Int'>
    readonly status: FieldRef<"Seat", 'SeatStatus'>
    readonly createdAt: FieldRef<"Seat", 'DateTime'>
    readonly updatedAt: FieldRef<"Seat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Seat findUnique
   */
  export type SeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat findUniqueOrThrow
   */
  export type SeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat findFirst
   */
  export type SeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat findFirstOrThrow
   */
  export type SeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat findMany
   */
  export type SeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seats to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat create
   */
  export type SeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The data needed to create a Seat.
     */
    data: XOR<SeatCreateInput, SeatUncheckedCreateInput>
  }

  /**
   * Seat createMany
   */
  export type SeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seats.
     */
    data: SeatCreateManyInput | SeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seat createManyAndReturn
   */
  export type SeatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * The data used to create many Seats.
     */
    data: SeatCreateManyInput | SeatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Seat update
   */
  export type SeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The data needed to update a Seat.
     */
    data: XOR<SeatUpdateInput, SeatUncheckedUpdateInput>
    /**
     * Choose, which Seat to update.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat updateMany
   */
  export type SeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seats.
     */
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyInput>
    /**
     * Filter which Seats to update
     */
    where?: SeatWhereInput
    /**
     * Limit how many Seats to update.
     */
    limit?: number
  }

  /**
   * Seat updateManyAndReturn
   */
  export type SeatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * The data used to update Seats.
     */
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyInput>
    /**
     * Filter which Seats to update
     */
    where?: SeatWhereInput
    /**
     * Limit how many Seats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Seat upsert
   */
  export type SeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The filter to search for the Seat to update in case it exists.
     */
    where: SeatWhereUniqueInput
    /**
     * In case the Seat found by the `where` argument doesn't exist, create a new Seat with this data.
     */
    create: XOR<SeatCreateInput, SeatUncheckedCreateInput>
    /**
     * In case the Seat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatUpdateInput, SeatUncheckedUpdateInput>
  }

  /**
   * Seat delete
   */
  export type SeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter which Seat to delete.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat deleteMany
   */
  export type SeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seats to delete
     */
    where?: SeatWhereInput
    /**
     * Limit how many Seats to delete.
     */
    limit?: number
  }

  /**
   * Seat.attributes
   */
  export type Seat$attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatAttributeAssignment
     */
    select?: SeatAttributeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeatAttributeAssignment
     */
    omit?: SeatAttributeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatAttributeAssignmentInclude<ExtArgs> | null
    where?: SeatAttributeAssignmentWhereInput
    orderBy?: SeatAttributeAssignmentOrderByWithRelationInput | SeatAttributeAssignmentOrderByWithRelationInput[]
    cursor?: SeatAttributeAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatAttributeAssignmentScalarFieldEnum | SeatAttributeAssignmentScalarFieldEnum[]
  }

  /**
   * Seat.layouts
   */
  export type Seat$layoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    where?: LayoutSeatWhereInput
    orderBy?: LayoutSeatOrderByWithRelationInput | LayoutSeatOrderByWithRelationInput[]
    cursor?: LayoutSeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LayoutSeatScalarFieldEnum | LayoutSeatScalarFieldEnum[]
  }

  /**
   * Seat without action
   */
  export type SeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seat
     */
    omit?: SeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
  }


  /**
   * Model Layout
   */

  export type AggregateLayout = {
    _count: LayoutCountAggregateOutputType | null
    _avg: LayoutAvgAggregateOutputType | null
    _sum: LayoutSumAggregateOutputType | null
    _min: LayoutMinAggregateOutputType | null
    _max: LayoutMaxAggregateOutputType | null
  }

  export type LayoutAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type LayoutSumAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
  }

  export type LayoutMinAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    name: string | null
    status: $Enums.LayoutStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LayoutMaxAggregateOutputType = {
    id: bigint | null
    storeId: bigint | null
    name: string | null
    status: $Enums.LayoutStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LayoutCountAggregateOutputType = {
    id: number
    storeId: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LayoutAvgAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type LayoutSumAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type LayoutMinAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LayoutMaxAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LayoutCountAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Layout to aggregate.
     */
    where?: LayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layouts to fetch.
     */
    orderBy?: LayoutOrderByWithRelationInput | LayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Layouts
    **/
    _count?: true | LayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LayoutMaxAggregateInputType
  }

  export type GetLayoutAggregateType<T extends LayoutAggregateArgs> = {
        [P in keyof T & keyof AggregateLayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLayout[P]>
      : GetScalarType<T[P], AggregateLayout[P]>
  }




  export type LayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayoutWhereInput
    orderBy?: LayoutOrderByWithAggregationInput | LayoutOrderByWithAggregationInput[]
    by: LayoutScalarFieldEnum[] | LayoutScalarFieldEnum
    having?: LayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LayoutCountAggregateInputType | true
    _avg?: LayoutAvgAggregateInputType
    _sum?: LayoutSumAggregateInputType
    _min?: LayoutMinAggregateInputType
    _max?: LayoutMaxAggregateInputType
  }

  export type LayoutGroupByOutputType = {
    id: bigint
    storeId: bigint
    name: string
    status: $Enums.LayoutStatus
    createdAt: Date
    updatedAt: Date
    _count: LayoutCountAggregateOutputType | null
    _avg: LayoutAvgAggregateOutputType | null
    _sum: LayoutSumAggregateOutputType | null
    _min: LayoutMinAggregateOutputType | null
    _max: LayoutMaxAggregateOutputType | null
  }

  type GetLayoutGroupByPayload<T extends LayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LayoutGroupByOutputType[P]>
            : GetScalarType<T[P], LayoutGroupByOutputType[P]>
        }
      >
    >


  export type LayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    seats?: boolean | Layout$seatsArgs<ExtArgs>
    _count?: boolean | LayoutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["layout"]>

  export type LayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["layout"]>

  export type LayoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["layout"]>

  export type LayoutSelectScalar = {
    id?: boolean
    storeId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeId" | "name" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["layout"]>
  export type LayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    seats?: boolean | Layout$seatsArgs<ExtArgs>
    _count?: boolean | LayoutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type LayoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $LayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Layout"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      seats: Prisma.$LayoutSeatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      storeId: bigint
      name: string
      status: $Enums.LayoutStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["layout"]>
    composites: {}
  }

  type LayoutGetPayload<S extends boolean | null | undefined | LayoutDefaultArgs> = $Result.GetResult<Prisma.$LayoutPayload, S>

  type LayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LayoutCountAggregateInputType | true
    }

  export interface LayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Layout'], meta: { name: 'Layout' } }
    /**
     * Find zero or one Layout that matches the filter.
     * @param {LayoutFindUniqueArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LayoutFindUniqueArgs>(args: SelectSubset<T, LayoutFindUniqueArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Layout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LayoutFindUniqueOrThrowArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, LayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Layout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutFindFirstArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LayoutFindFirstArgs>(args?: SelectSubset<T, LayoutFindFirstArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Layout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutFindFirstOrThrowArgs} args - Arguments to find a Layout
     * @example
     * // Get one Layout
     * const layout = await prisma.layout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, LayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Layouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Layouts
     * const layouts = await prisma.layout.findMany()
     * 
     * // Get first 10 Layouts
     * const layouts = await prisma.layout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const layoutWithIdOnly = await prisma.layout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LayoutFindManyArgs>(args?: SelectSubset<T, LayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Layout.
     * @param {LayoutCreateArgs} args - Arguments to create a Layout.
     * @example
     * // Create one Layout
     * const Layout = await prisma.layout.create({
     *   data: {
     *     // ... data to create a Layout
     *   }
     * })
     * 
     */
    create<T extends LayoutCreateArgs>(args: SelectSubset<T, LayoutCreateArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Layouts.
     * @param {LayoutCreateManyArgs} args - Arguments to create many Layouts.
     * @example
     * // Create many Layouts
     * const layout = await prisma.layout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LayoutCreateManyArgs>(args?: SelectSubset<T, LayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Layouts and returns the data saved in the database.
     * @param {LayoutCreateManyAndReturnArgs} args - Arguments to create many Layouts.
     * @example
     * // Create many Layouts
     * const layout = await prisma.layout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Layouts and only return the `id`
     * const layoutWithIdOnly = await prisma.layout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, LayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Layout.
     * @param {LayoutDeleteArgs} args - Arguments to delete one Layout.
     * @example
     * // Delete one Layout
     * const Layout = await prisma.layout.delete({
     *   where: {
     *     // ... filter to delete one Layout
     *   }
     * })
     * 
     */
    delete<T extends LayoutDeleteArgs>(args: SelectSubset<T, LayoutDeleteArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Layout.
     * @param {LayoutUpdateArgs} args - Arguments to update one Layout.
     * @example
     * // Update one Layout
     * const layout = await prisma.layout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LayoutUpdateArgs>(args: SelectSubset<T, LayoutUpdateArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Layouts.
     * @param {LayoutDeleteManyArgs} args - Arguments to filter Layouts to delete.
     * @example
     * // Delete a few Layouts
     * const { count } = await prisma.layout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LayoutDeleteManyArgs>(args?: SelectSubset<T, LayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Layouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Layouts
     * const layout = await prisma.layout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LayoutUpdateManyArgs>(args: SelectSubset<T, LayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Layouts and returns the data updated in the database.
     * @param {LayoutUpdateManyAndReturnArgs} args - Arguments to update many Layouts.
     * @example
     * // Update many Layouts
     * const layout = await prisma.layout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Layouts and only return the `id`
     * const layoutWithIdOnly = await prisma.layout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LayoutUpdateManyAndReturnArgs>(args: SelectSubset<T, LayoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Layout.
     * @param {LayoutUpsertArgs} args - Arguments to update or create a Layout.
     * @example
     * // Update or create a Layout
     * const layout = await prisma.layout.upsert({
     *   create: {
     *     // ... data to create a Layout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Layout we want to update
     *   }
     * })
     */
    upsert<T extends LayoutUpsertArgs>(args: SelectSubset<T, LayoutUpsertArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Layouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutCountArgs} args - Arguments to filter Layouts to count.
     * @example
     * // Count the number of Layouts
     * const count = await prisma.layout.count({
     *   where: {
     *     // ... the filter for the Layouts we want to count
     *   }
     * })
    **/
    count<T extends LayoutCountArgs>(
      args?: Subset<T, LayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Layout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LayoutAggregateArgs>(args: Subset<T, LayoutAggregateArgs>): Prisma.PrismaPromise<GetLayoutAggregateType<T>>

    /**
     * Group by Layout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LayoutGroupByArgs['orderBy'] }
        : { orderBy?: LayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Layout model
   */
  readonly fields: LayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Layout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seats<T extends Layout$seatsArgs<ExtArgs> = {}>(args?: Subset<T, Layout$seatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Layout model
   */
  interface LayoutFieldRefs {
    readonly id: FieldRef<"Layout", 'BigInt'>
    readonly storeId: FieldRef<"Layout", 'BigInt'>
    readonly name: FieldRef<"Layout", 'String'>
    readonly status: FieldRef<"Layout", 'LayoutStatus'>
    readonly createdAt: FieldRef<"Layout", 'DateTime'>
    readonly updatedAt: FieldRef<"Layout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Layout findUnique
   */
  export type LayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layout to fetch.
     */
    where: LayoutWhereUniqueInput
  }

  /**
   * Layout findUniqueOrThrow
   */
  export type LayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layout to fetch.
     */
    where: LayoutWhereUniqueInput
  }

  /**
   * Layout findFirst
   */
  export type LayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layout to fetch.
     */
    where?: LayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layouts to fetch.
     */
    orderBy?: LayoutOrderByWithRelationInput | LayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Layouts.
     */
    cursor?: LayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Layouts.
     */
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[]
  }

  /**
   * Layout findFirstOrThrow
   */
  export type LayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layout to fetch.
     */
    where?: LayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layouts to fetch.
     */
    orderBy?: LayoutOrderByWithRelationInput | LayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Layouts.
     */
    cursor?: LayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Layouts.
     */
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[]
  }

  /**
   * Layout findMany
   */
  export type LayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter, which Layouts to fetch.
     */
    where?: LayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layouts to fetch.
     */
    orderBy?: LayoutOrderByWithRelationInput | LayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Layouts.
     */
    cursor?: LayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layouts.
     */
    skip?: number
    distinct?: LayoutScalarFieldEnum | LayoutScalarFieldEnum[]
  }

  /**
   * Layout create
   */
  export type LayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Layout.
     */
    data: XOR<LayoutCreateInput, LayoutUncheckedCreateInput>
  }

  /**
   * Layout createMany
   */
  export type LayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Layouts.
     */
    data: LayoutCreateManyInput | LayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Layout createManyAndReturn
   */
  export type LayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * The data used to create many Layouts.
     */
    data: LayoutCreateManyInput | LayoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Layout update
   */
  export type LayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Layout.
     */
    data: XOR<LayoutUpdateInput, LayoutUncheckedUpdateInput>
    /**
     * Choose, which Layout to update.
     */
    where: LayoutWhereUniqueInput
  }

  /**
   * Layout updateMany
   */
  export type LayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Layouts.
     */
    data: XOR<LayoutUpdateManyMutationInput, LayoutUncheckedUpdateManyInput>
    /**
     * Filter which Layouts to update
     */
    where?: LayoutWhereInput
    /**
     * Limit how many Layouts to update.
     */
    limit?: number
  }

  /**
   * Layout updateManyAndReturn
   */
  export type LayoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * The data used to update Layouts.
     */
    data: XOR<LayoutUpdateManyMutationInput, LayoutUncheckedUpdateManyInput>
    /**
     * Filter which Layouts to update
     */
    where?: LayoutWhereInput
    /**
     * Limit how many Layouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Layout upsert
   */
  export type LayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Layout to update in case it exists.
     */
    where: LayoutWhereUniqueInput
    /**
     * In case the Layout found by the `where` argument doesn't exist, create a new Layout with this data.
     */
    create: XOR<LayoutCreateInput, LayoutUncheckedCreateInput>
    /**
     * In case the Layout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LayoutUpdateInput, LayoutUncheckedUpdateInput>
  }

  /**
   * Layout delete
   */
  export type LayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
    /**
     * Filter which Layout to delete.
     */
    where: LayoutWhereUniqueInput
  }

  /**
   * Layout deleteMany
   */
  export type LayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Layouts to delete
     */
    where?: LayoutWhereInput
    /**
     * Limit how many Layouts to delete.
     */
    limit?: number
  }

  /**
   * Layout.seats
   */
  export type Layout$seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    where?: LayoutSeatWhereInput
    orderBy?: LayoutSeatOrderByWithRelationInput | LayoutSeatOrderByWithRelationInput[]
    cursor?: LayoutSeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LayoutSeatScalarFieldEnum | LayoutSeatScalarFieldEnum[]
  }

  /**
   * Layout without action
   */
  export type LayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layout
     */
    select?: LayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layout
     */
    omit?: LayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutInclude<ExtArgs> | null
  }


  /**
   * Model LayoutSeat
   */

  export type AggregateLayoutSeat = {
    _count: LayoutSeatCountAggregateOutputType | null
    _avg: LayoutSeatAvgAggregateOutputType | null
    _sum: LayoutSeatSumAggregateOutputType | null
    _min: LayoutSeatMinAggregateOutputType | null
    _max: LayoutSeatMaxAggregateOutputType | null
  }

  export type LayoutSeatAvgAggregateOutputType = {
    layoutId: number | null
    seatId: number | null
  }

  export type LayoutSeatSumAggregateOutputType = {
    layoutId: bigint | null
    seatId: bigint | null
  }

  export type LayoutSeatMinAggregateOutputType = {
    layoutId: bigint | null
    seatId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LayoutSeatMaxAggregateOutputType = {
    layoutId: bigint | null
    seatId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LayoutSeatCountAggregateOutputType = {
    layoutId: number
    seatId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LayoutSeatAvgAggregateInputType = {
    layoutId?: true
    seatId?: true
  }

  export type LayoutSeatSumAggregateInputType = {
    layoutId?: true
    seatId?: true
  }

  export type LayoutSeatMinAggregateInputType = {
    layoutId?: true
    seatId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LayoutSeatMaxAggregateInputType = {
    layoutId?: true
    seatId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LayoutSeatCountAggregateInputType = {
    layoutId?: true
    seatId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LayoutSeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LayoutSeat to aggregate.
     */
    where?: LayoutSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LayoutSeats to fetch.
     */
    orderBy?: LayoutSeatOrderByWithRelationInput | LayoutSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LayoutSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LayoutSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LayoutSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LayoutSeats
    **/
    _count?: true | LayoutSeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LayoutSeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LayoutSeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LayoutSeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LayoutSeatMaxAggregateInputType
  }

  export type GetLayoutSeatAggregateType<T extends LayoutSeatAggregateArgs> = {
        [P in keyof T & keyof AggregateLayoutSeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLayoutSeat[P]>
      : GetScalarType<T[P], AggregateLayoutSeat[P]>
  }




  export type LayoutSeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayoutSeatWhereInput
    orderBy?: LayoutSeatOrderByWithAggregationInput | LayoutSeatOrderByWithAggregationInput[]
    by: LayoutSeatScalarFieldEnum[] | LayoutSeatScalarFieldEnum
    having?: LayoutSeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LayoutSeatCountAggregateInputType | true
    _avg?: LayoutSeatAvgAggregateInputType
    _sum?: LayoutSeatSumAggregateInputType
    _min?: LayoutSeatMinAggregateInputType
    _max?: LayoutSeatMaxAggregateInputType
  }

  export type LayoutSeatGroupByOutputType = {
    layoutId: bigint
    seatId: bigint
    createdAt: Date
    updatedAt: Date
    _count: LayoutSeatCountAggregateOutputType | null
    _avg: LayoutSeatAvgAggregateOutputType | null
    _sum: LayoutSeatSumAggregateOutputType | null
    _min: LayoutSeatMinAggregateOutputType | null
    _max: LayoutSeatMaxAggregateOutputType | null
  }

  type GetLayoutSeatGroupByPayload<T extends LayoutSeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LayoutSeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LayoutSeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LayoutSeatGroupByOutputType[P]>
            : GetScalarType<T[P], LayoutSeatGroupByOutputType[P]>
        }
      >
    >


  export type LayoutSeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    layoutId?: boolean
    seatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["layoutSeat"]>

  export type LayoutSeatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    layoutId?: boolean
    seatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["layoutSeat"]>

  export type LayoutSeatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    layoutId?: boolean
    seatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["layoutSeat"]>

  export type LayoutSeatSelectScalar = {
    layoutId?: boolean
    seatId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LayoutSeatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"layoutId" | "seatId" | "createdAt" | "updatedAt", ExtArgs["result"]["layoutSeat"]>
  export type LayoutSeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }
  export type LayoutSeatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }
  export type LayoutSeatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    layout?: boolean | LayoutDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }

  export type $LayoutSeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LayoutSeat"
    objects: {
      layout: Prisma.$LayoutPayload<ExtArgs>
      seat: Prisma.$SeatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      layoutId: bigint
      seatId: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["layoutSeat"]>
    composites: {}
  }

  type LayoutSeatGetPayload<S extends boolean | null | undefined | LayoutSeatDefaultArgs> = $Result.GetResult<Prisma.$LayoutSeatPayload, S>

  type LayoutSeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LayoutSeatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LayoutSeatCountAggregateInputType | true
    }

  export interface LayoutSeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LayoutSeat'], meta: { name: 'LayoutSeat' } }
    /**
     * Find zero or one LayoutSeat that matches the filter.
     * @param {LayoutSeatFindUniqueArgs} args - Arguments to find a LayoutSeat
     * @example
     * // Get one LayoutSeat
     * const layoutSeat = await prisma.layoutSeat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LayoutSeatFindUniqueArgs>(args: SelectSubset<T, LayoutSeatFindUniqueArgs<ExtArgs>>): Prisma__LayoutSeatClient<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LayoutSeat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LayoutSeatFindUniqueOrThrowArgs} args - Arguments to find a LayoutSeat
     * @example
     * // Get one LayoutSeat
     * const layoutSeat = await prisma.layoutSeat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LayoutSeatFindUniqueOrThrowArgs>(args: SelectSubset<T, LayoutSeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LayoutSeatClient<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LayoutSeat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutSeatFindFirstArgs} args - Arguments to find a LayoutSeat
     * @example
     * // Get one LayoutSeat
     * const layoutSeat = await prisma.layoutSeat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LayoutSeatFindFirstArgs>(args?: SelectSubset<T, LayoutSeatFindFirstArgs<ExtArgs>>): Prisma__LayoutSeatClient<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LayoutSeat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutSeatFindFirstOrThrowArgs} args - Arguments to find a LayoutSeat
     * @example
     * // Get one LayoutSeat
     * const layoutSeat = await prisma.layoutSeat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LayoutSeatFindFirstOrThrowArgs>(args?: SelectSubset<T, LayoutSeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__LayoutSeatClient<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LayoutSeats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutSeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LayoutSeats
     * const layoutSeats = await prisma.layoutSeat.findMany()
     * 
     * // Get first 10 LayoutSeats
     * const layoutSeats = await prisma.layoutSeat.findMany({ take: 10 })
     * 
     * // Only select the `layoutId`
     * const layoutSeatWithLayoutIdOnly = await prisma.layoutSeat.findMany({ select: { layoutId: true } })
     * 
     */
    findMany<T extends LayoutSeatFindManyArgs>(args?: SelectSubset<T, LayoutSeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LayoutSeat.
     * @param {LayoutSeatCreateArgs} args - Arguments to create a LayoutSeat.
     * @example
     * // Create one LayoutSeat
     * const LayoutSeat = await prisma.layoutSeat.create({
     *   data: {
     *     // ... data to create a LayoutSeat
     *   }
     * })
     * 
     */
    create<T extends LayoutSeatCreateArgs>(args: SelectSubset<T, LayoutSeatCreateArgs<ExtArgs>>): Prisma__LayoutSeatClient<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LayoutSeats.
     * @param {LayoutSeatCreateManyArgs} args - Arguments to create many LayoutSeats.
     * @example
     * // Create many LayoutSeats
     * const layoutSeat = await prisma.layoutSeat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LayoutSeatCreateManyArgs>(args?: SelectSubset<T, LayoutSeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LayoutSeats and returns the data saved in the database.
     * @param {LayoutSeatCreateManyAndReturnArgs} args - Arguments to create many LayoutSeats.
     * @example
     * // Create many LayoutSeats
     * const layoutSeat = await prisma.layoutSeat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LayoutSeats and only return the `layoutId`
     * const layoutSeatWithLayoutIdOnly = await prisma.layoutSeat.createManyAndReturn({
     *   select: { layoutId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LayoutSeatCreateManyAndReturnArgs>(args?: SelectSubset<T, LayoutSeatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LayoutSeat.
     * @param {LayoutSeatDeleteArgs} args - Arguments to delete one LayoutSeat.
     * @example
     * // Delete one LayoutSeat
     * const LayoutSeat = await prisma.layoutSeat.delete({
     *   where: {
     *     // ... filter to delete one LayoutSeat
     *   }
     * })
     * 
     */
    delete<T extends LayoutSeatDeleteArgs>(args: SelectSubset<T, LayoutSeatDeleteArgs<ExtArgs>>): Prisma__LayoutSeatClient<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LayoutSeat.
     * @param {LayoutSeatUpdateArgs} args - Arguments to update one LayoutSeat.
     * @example
     * // Update one LayoutSeat
     * const layoutSeat = await prisma.layoutSeat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LayoutSeatUpdateArgs>(args: SelectSubset<T, LayoutSeatUpdateArgs<ExtArgs>>): Prisma__LayoutSeatClient<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LayoutSeats.
     * @param {LayoutSeatDeleteManyArgs} args - Arguments to filter LayoutSeats to delete.
     * @example
     * // Delete a few LayoutSeats
     * const { count } = await prisma.layoutSeat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LayoutSeatDeleteManyArgs>(args?: SelectSubset<T, LayoutSeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LayoutSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutSeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LayoutSeats
     * const layoutSeat = await prisma.layoutSeat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LayoutSeatUpdateManyArgs>(args: SelectSubset<T, LayoutSeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LayoutSeats and returns the data updated in the database.
     * @param {LayoutSeatUpdateManyAndReturnArgs} args - Arguments to update many LayoutSeats.
     * @example
     * // Update many LayoutSeats
     * const layoutSeat = await prisma.layoutSeat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LayoutSeats and only return the `layoutId`
     * const layoutSeatWithLayoutIdOnly = await prisma.layoutSeat.updateManyAndReturn({
     *   select: { layoutId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LayoutSeatUpdateManyAndReturnArgs>(args: SelectSubset<T, LayoutSeatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LayoutSeat.
     * @param {LayoutSeatUpsertArgs} args - Arguments to update or create a LayoutSeat.
     * @example
     * // Update or create a LayoutSeat
     * const layoutSeat = await prisma.layoutSeat.upsert({
     *   create: {
     *     // ... data to create a LayoutSeat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LayoutSeat we want to update
     *   }
     * })
     */
    upsert<T extends LayoutSeatUpsertArgs>(args: SelectSubset<T, LayoutSeatUpsertArgs<ExtArgs>>): Prisma__LayoutSeatClient<$Result.GetResult<Prisma.$LayoutSeatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LayoutSeats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutSeatCountArgs} args - Arguments to filter LayoutSeats to count.
     * @example
     * // Count the number of LayoutSeats
     * const count = await prisma.layoutSeat.count({
     *   where: {
     *     // ... the filter for the LayoutSeats we want to count
     *   }
     * })
    **/
    count<T extends LayoutSeatCountArgs>(
      args?: Subset<T, LayoutSeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LayoutSeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LayoutSeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutSeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LayoutSeatAggregateArgs>(args: Subset<T, LayoutSeatAggregateArgs>): Prisma.PrismaPromise<GetLayoutSeatAggregateType<T>>

    /**
     * Group by LayoutSeat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayoutSeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LayoutSeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LayoutSeatGroupByArgs['orderBy'] }
        : { orderBy?: LayoutSeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LayoutSeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLayoutSeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LayoutSeat model
   */
  readonly fields: LayoutSeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LayoutSeat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LayoutSeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    layout<T extends LayoutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LayoutDefaultArgs<ExtArgs>>): Prisma__LayoutClient<$Result.GetResult<Prisma.$LayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seat<T extends SeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeatDefaultArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LayoutSeat model
   */
  interface LayoutSeatFieldRefs {
    readonly layoutId: FieldRef<"LayoutSeat", 'BigInt'>
    readonly seatId: FieldRef<"LayoutSeat", 'BigInt'>
    readonly createdAt: FieldRef<"LayoutSeat", 'DateTime'>
    readonly updatedAt: FieldRef<"LayoutSeat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LayoutSeat findUnique
   */
  export type LayoutSeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    /**
     * Filter, which LayoutSeat to fetch.
     */
    where: LayoutSeatWhereUniqueInput
  }

  /**
   * LayoutSeat findUniqueOrThrow
   */
  export type LayoutSeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    /**
     * Filter, which LayoutSeat to fetch.
     */
    where: LayoutSeatWhereUniqueInput
  }

  /**
   * LayoutSeat findFirst
   */
  export type LayoutSeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    /**
     * Filter, which LayoutSeat to fetch.
     */
    where?: LayoutSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LayoutSeats to fetch.
     */
    orderBy?: LayoutSeatOrderByWithRelationInput | LayoutSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LayoutSeats.
     */
    cursor?: LayoutSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LayoutSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LayoutSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LayoutSeats.
     */
    distinct?: LayoutSeatScalarFieldEnum | LayoutSeatScalarFieldEnum[]
  }

  /**
   * LayoutSeat findFirstOrThrow
   */
  export type LayoutSeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    /**
     * Filter, which LayoutSeat to fetch.
     */
    where?: LayoutSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LayoutSeats to fetch.
     */
    orderBy?: LayoutSeatOrderByWithRelationInput | LayoutSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LayoutSeats.
     */
    cursor?: LayoutSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LayoutSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LayoutSeats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LayoutSeats.
     */
    distinct?: LayoutSeatScalarFieldEnum | LayoutSeatScalarFieldEnum[]
  }

  /**
   * LayoutSeat findMany
   */
  export type LayoutSeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    /**
     * Filter, which LayoutSeats to fetch.
     */
    where?: LayoutSeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LayoutSeats to fetch.
     */
    orderBy?: LayoutSeatOrderByWithRelationInput | LayoutSeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LayoutSeats.
     */
    cursor?: LayoutSeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LayoutSeats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LayoutSeats.
     */
    skip?: number
    distinct?: LayoutSeatScalarFieldEnum | LayoutSeatScalarFieldEnum[]
  }

  /**
   * LayoutSeat create
   */
  export type LayoutSeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    /**
     * The data needed to create a LayoutSeat.
     */
    data: XOR<LayoutSeatCreateInput, LayoutSeatUncheckedCreateInput>
  }

  /**
   * LayoutSeat createMany
   */
  export type LayoutSeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LayoutSeats.
     */
    data: LayoutSeatCreateManyInput | LayoutSeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LayoutSeat createManyAndReturn
   */
  export type LayoutSeatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * The data used to create many LayoutSeats.
     */
    data: LayoutSeatCreateManyInput | LayoutSeatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LayoutSeat update
   */
  export type LayoutSeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    /**
     * The data needed to update a LayoutSeat.
     */
    data: XOR<LayoutSeatUpdateInput, LayoutSeatUncheckedUpdateInput>
    /**
     * Choose, which LayoutSeat to update.
     */
    where: LayoutSeatWhereUniqueInput
  }

  /**
   * LayoutSeat updateMany
   */
  export type LayoutSeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LayoutSeats.
     */
    data: XOR<LayoutSeatUpdateManyMutationInput, LayoutSeatUncheckedUpdateManyInput>
    /**
     * Filter which LayoutSeats to update
     */
    where?: LayoutSeatWhereInput
    /**
     * Limit how many LayoutSeats to update.
     */
    limit?: number
  }

  /**
   * LayoutSeat updateManyAndReturn
   */
  export type LayoutSeatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * The data used to update LayoutSeats.
     */
    data: XOR<LayoutSeatUpdateManyMutationInput, LayoutSeatUncheckedUpdateManyInput>
    /**
     * Filter which LayoutSeats to update
     */
    where?: LayoutSeatWhereInput
    /**
     * Limit how many LayoutSeats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LayoutSeat upsert
   */
  export type LayoutSeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    /**
     * The filter to search for the LayoutSeat to update in case it exists.
     */
    where: LayoutSeatWhereUniqueInput
    /**
     * In case the LayoutSeat found by the `where` argument doesn't exist, create a new LayoutSeat with this data.
     */
    create: XOR<LayoutSeatCreateInput, LayoutSeatUncheckedCreateInput>
    /**
     * In case the LayoutSeat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LayoutSeatUpdateInput, LayoutSeatUncheckedUpdateInput>
  }

  /**
   * LayoutSeat delete
   */
  export type LayoutSeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
    /**
     * Filter which LayoutSeat to delete.
     */
    where: LayoutSeatWhereUniqueInput
  }

  /**
   * LayoutSeat deleteMany
   */
  export type LayoutSeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LayoutSeats to delete
     */
    where?: LayoutSeatWhereInput
    /**
     * Limit how many LayoutSeats to delete.
     */
    limit?: number
  }

  /**
   * LayoutSeat without action
   */
  export type LayoutSeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayoutSeat
     */
    select?: LayoutSeatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LayoutSeat
     */
    omit?: LayoutSeatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayoutSeatInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const UserAccountScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    role: 'role',
    userId: 'userId',
    username: 'username',
    passwordHash: 'passwordHash',
    status: 'status',
    isLocked: 'isLocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAccountScalarFieldEnum = (typeof UserAccountScalarFieldEnum)[keyof typeof UserAccountScalarFieldEnum]


  export const SeatAttributeGroupScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    name: 'name',
    selectionType: 'selectionType',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeatAttributeGroupScalarFieldEnum = (typeof SeatAttributeGroupScalarFieldEnum)[keyof typeof SeatAttributeGroupScalarFieldEnum]


  export const SeatAttributeScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    groupId: 'groupId',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeatAttributeScalarFieldEnum = (typeof SeatAttributeScalarFieldEnum)[keyof typeof SeatAttributeScalarFieldEnum]


  export const SeatAttributeAssignmentScalarFieldEnum: {
    seatId: 'seatId',
    attributeId: 'attributeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeatAttributeAssignmentScalarFieldEnum = (typeof SeatAttributeAssignmentScalarFieldEnum)[keyof typeof SeatAttributeAssignmentScalarFieldEnum]


  export const SeatScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    name: 'name',
    minCapacity: 'minCapacity',
    maxCapacity: 'maxCapacity',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeatScalarFieldEnum = (typeof SeatScalarFieldEnum)[keyof typeof SeatScalarFieldEnum]


  export const LayoutScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LayoutScalarFieldEnum = (typeof LayoutScalarFieldEnum)[keyof typeof LayoutScalarFieldEnum]


  export const LayoutSeatScalarFieldEnum: {
    layoutId: 'layoutId',
    seatId: 'seatId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LayoutSeatScalarFieldEnum = (typeof LayoutSeatScalarFieldEnum)[keyof typeof LayoutSeatScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'StoreStatus'
   */
  export type EnumStoreStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreStatus'>
    


  /**
   * Reference to a field of type 'StoreStatus[]'
   */
  export type ListEnumStoreStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SelectionType'
   */
  export type EnumSelectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SelectionType'>
    


  /**
   * Reference to a field of type 'SelectionType[]'
   */
  export type ListEnumSelectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SelectionType[]'>
    


  /**
   * Reference to a field of type 'AttributeStatus'
   */
  export type EnumAttributeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttributeStatus'>
    


  /**
   * Reference to a field of type 'AttributeStatus[]'
   */
  export type ListEnumAttributeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttributeStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'SeatStatus'
   */
  export type EnumSeatStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeatStatus'>
    


  /**
   * Reference to a field of type 'SeatStatus[]'
   */
  export type ListEnumSeatStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeatStatus[]'>
    


  /**
   * Reference to a field of type 'LayoutStatus'
   */
  export type EnumLayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LayoutStatus'>
    


  /**
   * Reference to a field of type 'LayoutStatus[]'
   */
  export type ListEnumLayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LayoutStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: BigIntFilter<"Store"> | bigint | number
    name?: StringFilter<"Store"> | string
    status?: EnumStoreStatusFilter<"Store"> | $Enums.StoreStatus
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    users?: UserAccountListRelationFilter
    seatAttributeGroups?: SeatAttributeGroupListRelationFilter
    seatAttributes?: SeatAttributeListRelationFilter
    seats?: SeatListRelationFilter
    layouts?: LayoutListRelationFilter
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserAccountOrderByRelationAggregateInput
    seatAttributeGroups?: SeatAttributeGroupOrderByRelationAggregateInput
    seatAttributes?: SeatAttributeOrderByRelationAggregateInput
    seats?: SeatOrderByRelationAggregateInput
    layouts?: LayoutOrderByRelationAggregateInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    name?: StringFilter<"Store"> | string
    status?: EnumStoreStatusFilter<"Store"> | $Enums.StoreStatus
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    users?: UserAccountListRelationFilter
    seatAttributeGroups?: SeatAttributeGroupListRelationFilter
    seatAttributes?: SeatAttributeListRelationFilter
    seats?: SeatListRelationFilter
    layouts?: LayoutListRelationFilter
  }, "id">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _avg?: StoreAvgOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
    _sum?: StoreSumOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Store"> | bigint | number
    name?: StringWithAggregatesFilter<"Store"> | string
    status?: EnumStoreStatusWithAggregatesFilter<"Store"> | $Enums.StoreStatus
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
  }

  export type UserAccountWhereInput = {
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    id?: BigIntFilter<"UserAccount"> | bigint | number
    storeId?: BigIntNullableFilter<"UserAccount"> | bigint | number | null
    role?: EnumRoleFilter<"UserAccount"> | $Enums.Role
    userId?: StringFilter<"UserAccount"> | string
    username?: StringFilter<"UserAccount"> | string
    passwordHash?: StringFilter<"UserAccount"> | string
    status?: EnumUserStatusFilter<"UserAccount"> | $Enums.UserStatus
    isLocked?: BoolFilter<"UserAccount"> | boolean
    createdAt?: DateTimeFilter<"UserAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserAccount"> | Date | string
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
  }

  export type UserAccountOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrderInput | SortOrder
    role?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type UserAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    userId?: string
    AND?: UserAccountWhereInput | UserAccountWhereInput[]
    OR?: UserAccountWhereInput[]
    NOT?: UserAccountWhereInput | UserAccountWhereInput[]
    storeId?: BigIntNullableFilter<"UserAccount"> | bigint | number | null
    role?: EnumRoleFilter<"UserAccount"> | $Enums.Role
    username?: StringFilter<"UserAccount"> | string
    passwordHash?: StringFilter<"UserAccount"> | string
    status?: EnumUserStatusFilter<"UserAccount"> | $Enums.UserStatus
    isLocked?: BoolFilter<"UserAccount"> | boolean
    createdAt?: DateTimeFilter<"UserAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserAccount"> | Date | string
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
  }, "id" | "userId">

  export type UserAccountOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrderInput | SortOrder
    role?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAccountCountOrderByAggregateInput
    _avg?: UserAccountAvgOrderByAggregateInput
    _max?: UserAccountMaxOrderByAggregateInput
    _min?: UserAccountMinOrderByAggregateInput
    _sum?: UserAccountSumOrderByAggregateInput
  }

  export type UserAccountScalarWhereWithAggregatesInput = {
    AND?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    OR?: UserAccountScalarWhereWithAggregatesInput[]
    NOT?: UserAccountScalarWhereWithAggregatesInput | UserAccountScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserAccount"> | bigint | number
    storeId?: BigIntNullableWithAggregatesFilter<"UserAccount"> | bigint | number | null
    role?: EnumRoleWithAggregatesFilter<"UserAccount"> | $Enums.Role
    userId?: StringWithAggregatesFilter<"UserAccount"> | string
    username?: StringWithAggregatesFilter<"UserAccount"> | string
    passwordHash?: StringWithAggregatesFilter<"UserAccount"> | string
    status?: EnumUserStatusWithAggregatesFilter<"UserAccount"> | $Enums.UserStatus
    isLocked?: BoolWithAggregatesFilter<"UserAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAccount"> | Date | string
  }

  export type SeatAttributeGroupWhereInput = {
    AND?: SeatAttributeGroupWhereInput | SeatAttributeGroupWhereInput[]
    OR?: SeatAttributeGroupWhereInput[]
    NOT?: SeatAttributeGroupWhereInput | SeatAttributeGroupWhereInput[]
    id?: BigIntFilter<"SeatAttributeGroup"> | bigint | number
    storeId?: BigIntFilter<"SeatAttributeGroup"> | bigint | number
    name?: StringFilter<"SeatAttributeGroup"> | string
    selectionType?: EnumSelectionTypeFilter<"SeatAttributeGroup"> | $Enums.SelectionType
    status?: EnumAttributeStatusFilter<"SeatAttributeGroup"> | $Enums.AttributeStatus
    createdAt?: DateTimeFilter<"SeatAttributeGroup"> | Date | string
    updatedAt?: DateTimeFilter<"SeatAttributeGroup"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    attributes?: SeatAttributeListRelationFilter
  }

  export type SeatAttributeGroupOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    selectionType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    attributes?: SeatAttributeOrderByRelationAggregateInput
  }

  export type SeatAttributeGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    storeId_name?: SeatAttributeGroupStoreIdNameCompoundUniqueInput
    AND?: SeatAttributeGroupWhereInput | SeatAttributeGroupWhereInput[]
    OR?: SeatAttributeGroupWhereInput[]
    NOT?: SeatAttributeGroupWhereInput | SeatAttributeGroupWhereInput[]
    storeId?: BigIntFilter<"SeatAttributeGroup"> | bigint | number
    name?: StringFilter<"SeatAttributeGroup"> | string
    selectionType?: EnumSelectionTypeFilter<"SeatAttributeGroup"> | $Enums.SelectionType
    status?: EnumAttributeStatusFilter<"SeatAttributeGroup"> | $Enums.AttributeStatus
    createdAt?: DateTimeFilter<"SeatAttributeGroup"> | Date | string
    updatedAt?: DateTimeFilter<"SeatAttributeGroup"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    attributes?: SeatAttributeListRelationFilter
  }, "id" | "storeId_name">

  export type SeatAttributeGroupOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    selectionType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeatAttributeGroupCountOrderByAggregateInput
    _avg?: SeatAttributeGroupAvgOrderByAggregateInput
    _max?: SeatAttributeGroupMaxOrderByAggregateInput
    _min?: SeatAttributeGroupMinOrderByAggregateInput
    _sum?: SeatAttributeGroupSumOrderByAggregateInput
  }

  export type SeatAttributeGroupScalarWhereWithAggregatesInput = {
    AND?: SeatAttributeGroupScalarWhereWithAggregatesInput | SeatAttributeGroupScalarWhereWithAggregatesInput[]
    OR?: SeatAttributeGroupScalarWhereWithAggregatesInput[]
    NOT?: SeatAttributeGroupScalarWhereWithAggregatesInput | SeatAttributeGroupScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"SeatAttributeGroup"> | bigint | number
    storeId?: BigIntWithAggregatesFilter<"SeatAttributeGroup"> | bigint | number
    name?: StringWithAggregatesFilter<"SeatAttributeGroup"> | string
    selectionType?: EnumSelectionTypeWithAggregatesFilter<"SeatAttributeGroup"> | $Enums.SelectionType
    status?: EnumAttributeStatusWithAggregatesFilter<"SeatAttributeGroup"> | $Enums.AttributeStatus
    createdAt?: DateTimeWithAggregatesFilter<"SeatAttributeGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SeatAttributeGroup"> | Date | string
  }

  export type SeatAttributeWhereInput = {
    AND?: SeatAttributeWhereInput | SeatAttributeWhereInput[]
    OR?: SeatAttributeWhereInput[]
    NOT?: SeatAttributeWhereInput | SeatAttributeWhereInput[]
    id?: BigIntFilter<"SeatAttribute"> | bigint | number
    storeId?: BigIntFilter<"SeatAttribute"> | bigint | number
    groupId?: BigIntFilter<"SeatAttribute"> | bigint | number
    name?: StringFilter<"SeatAttribute"> | string
    status?: EnumAttributeStatusFilter<"SeatAttribute"> | $Enums.AttributeStatus
    createdAt?: DateTimeFilter<"SeatAttribute"> | Date | string
    updatedAt?: DateTimeFilter<"SeatAttribute"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    group?: XOR<SeatAttributeGroupScalarRelationFilter, SeatAttributeGroupWhereInput>
    assignments?: SeatAttributeAssignmentListRelationFilter
  }

  export type SeatAttributeOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    group?: SeatAttributeGroupOrderByWithRelationInput
    assignments?: SeatAttributeAssignmentOrderByRelationAggregateInput
  }

  export type SeatAttributeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    storeId_groupId_name?: SeatAttributeStoreIdGroupIdNameCompoundUniqueInput
    AND?: SeatAttributeWhereInput | SeatAttributeWhereInput[]
    OR?: SeatAttributeWhereInput[]
    NOT?: SeatAttributeWhereInput | SeatAttributeWhereInput[]
    storeId?: BigIntFilter<"SeatAttribute"> | bigint | number
    groupId?: BigIntFilter<"SeatAttribute"> | bigint | number
    name?: StringFilter<"SeatAttribute"> | string
    status?: EnumAttributeStatusFilter<"SeatAttribute"> | $Enums.AttributeStatus
    createdAt?: DateTimeFilter<"SeatAttribute"> | Date | string
    updatedAt?: DateTimeFilter<"SeatAttribute"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    group?: XOR<SeatAttributeGroupScalarRelationFilter, SeatAttributeGroupWhereInput>
    assignments?: SeatAttributeAssignmentListRelationFilter
  }, "id" | "storeId_groupId_name">

  export type SeatAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeatAttributeCountOrderByAggregateInput
    _avg?: SeatAttributeAvgOrderByAggregateInput
    _max?: SeatAttributeMaxOrderByAggregateInput
    _min?: SeatAttributeMinOrderByAggregateInput
    _sum?: SeatAttributeSumOrderByAggregateInput
  }

  export type SeatAttributeScalarWhereWithAggregatesInput = {
    AND?: SeatAttributeScalarWhereWithAggregatesInput | SeatAttributeScalarWhereWithAggregatesInput[]
    OR?: SeatAttributeScalarWhereWithAggregatesInput[]
    NOT?: SeatAttributeScalarWhereWithAggregatesInput | SeatAttributeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"SeatAttribute"> | bigint | number
    storeId?: BigIntWithAggregatesFilter<"SeatAttribute"> | bigint | number
    groupId?: BigIntWithAggregatesFilter<"SeatAttribute"> | bigint | number
    name?: StringWithAggregatesFilter<"SeatAttribute"> | string
    status?: EnumAttributeStatusWithAggregatesFilter<"SeatAttribute"> | $Enums.AttributeStatus
    createdAt?: DateTimeWithAggregatesFilter<"SeatAttribute"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SeatAttribute"> | Date | string
  }

  export type SeatAttributeAssignmentWhereInput = {
    AND?: SeatAttributeAssignmentWhereInput | SeatAttributeAssignmentWhereInput[]
    OR?: SeatAttributeAssignmentWhereInput[]
    NOT?: SeatAttributeAssignmentWhereInput | SeatAttributeAssignmentWhereInput[]
    seatId?: BigIntFilter<"SeatAttributeAssignment"> | bigint | number
    attributeId?: BigIntFilter<"SeatAttributeAssignment"> | bigint | number
    createdAt?: DateTimeFilter<"SeatAttributeAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"SeatAttributeAssignment"> | Date | string
    seat?: XOR<SeatScalarRelationFilter, SeatWhereInput>
    attribute?: XOR<SeatAttributeScalarRelationFilter, SeatAttributeWhereInput>
  }

  export type SeatAttributeAssignmentOrderByWithRelationInput = {
    seatId?: SortOrder
    attributeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seat?: SeatOrderByWithRelationInput
    attribute?: SeatAttributeOrderByWithRelationInput
  }

  export type SeatAttributeAssignmentWhereUniqueInput = Prisma.AtLeast<{
    seatId_attributeId?: SeatAttributeAssignmentSeatIdAttributeIdCompoundUniqueInput
    AND?: SeatAttributeAssignmentWhereInput | SeatAttributeAssignmentWhereInput[]
    OR?: SeatAttributeAssignmentWhereInput[]
    NOT?: SeatAttributeAssignmentWhereInput | SeatAttributeAssignmentWhereInput[]
    seatId?: BigIntFilter<"SeatAttributeAssignment"> | bigint | number
    attributeId?: BigIntFilter<"SeatAttributeAssignment"> | bigint | number
    createdAt?: DateTimeFilter<"SeatAttributeAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"SeatAttributeAssignment"> | Date | string
    seat?: XOR<SeatScalarRelationFilter, SeatWhereInput>
    attribute?: XOR<SeatAttributeScalarRelationFilter, SeatAttributeWhereInput>
  }, "seatId_attributeId">

  export type SeatAttributeAssignmentOrderByWithAggregationInput = {
    seatId?: SortOrder
    attributeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeatAttributeAssignmentCountOrderByAggregateInput
    _avg?: SeatAttributeAssignmentAvgOrderByAggregateInput
    _max?: SeatAttributeAssignmentMaxOrderByAggregateInput
    _min?: SeatAttributeAssignmentMinOrderByAggregateInput
    _sum?: SeatAttributeAssignmentSumOrderByAggregateInput
  }

  export type SeatAttributeAssignmentScalarWhereWithAggregatesInput = {
    AND?: SeatAttributeAssignmentScalarWhereWithAggregatesInput | SeatAttributeAssignmentScalarWhereWithAggregatesInput[]
    OR?: SeatAttributeAssignmentScalarWhereWithAggregatesInput[]
    NOT?: SeatAttributeAssignmentScalarWhereWithAggregatesInput | SeatAttributeAssignmentScalarWhereWithAggregatesInput[]
    seatId?: BigIntWithAggregatesFilter<"SeatAttributeAssignment"> | bigint | number
    attributeId?: BigIntWithAggregatesFilter<"SeatAttributeAssignment"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"SeatAttributeAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SeatAttributeAssignment"> | Date | string
  }

  export type SeatWhereInput = {
    AND?: SeatWhereInput | SeatWhereInput[]
    OR?: SeatWhereInput[]
    NOT?: SeatWhereInput | SeatWhereInput[]
    id?: BigIntFilter<"Seat"> | bigint | number
    storeId?: BigIntFilter<"Seat"> | bigint | number
    name?: StringFilter<"Seat"> | string
    minCapacity?: IntFilter<"Seat"> | number
    maxCapacity?: IntFilter<"Seat"> | number
    status?: EnumSeatStatusFilter<"Seat"> | $Enums.SeatStatus
    createdAt?: DateTimeFilter<"Seat"> | Date | string
    updatedAt?: DateTimeFilter<"Seat"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    attributes?: SeatAttributeAssignmentListRelationFilter
    layouts?: LayoutSeatListRelationFilter
  }

  export type SeatOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    minCapacity?: SortOrder
    maxCapacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    attributes?: SeatAttributeAssignmentOrderByRelationAggregateInput
    layouts?: LayoutSeatOrderByRelationAggregateInput
  }

  export type SeatWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    storeId_name?: SeatStoreIdNameCompoundUniqueInput
    AND?: SeatWhereInput | SeatWhereInput[]
    OR?: SeatWhereInput[]
    NOT?: SeatWhereInput | SeatWhereInput[]
    storeId?: BigIntFilter<"Seat"> | bigint | number
    name?: StringFilter<"Seat"> | string
    minCapacity?: IntFilter<"Seat"> | number
    maxCapacity?: IntFilter<"Seat"> | number
    status?: EnumSeatStatusFilter<"Seat"> | $Enums.SeatStatus
    createdAt?: DateTimeFilter<"Seat"> | Date | string
    updatedAt?: DateTimeFilter<"Seat"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    attributes?: SeatAttributeAssignmentListRelationFilter
    layouts?: LayoutSeatListRelationFilter
  }, "id" | "storeId_name">

  export type SeatOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    minCapacity?: SortOrder
    maxCapacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeatCountOrderByAggregateInput
    _avg?: SeatAvgOrderByAggregateInput
    _max?: SeatMaxOrderByAggregateInput
    _min?: SeatMinOrderByAggregateInput
    _sum?: SeatSumOrderByAggregateInput
  }

  export type SeatScalarWhereWithAggregatesInput = {
    AND?: SeatScalarWhereWithAggregatesInput | SeatScalarWhereWithAggregatesInput[]
    OR?: SeatScalarWhereWithAggregatesInput[]
    NOT?: SeatScalarWhereWithAggregatesInput | SeatScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Seat"> | bigint | number
    storeId?: BigIntWithAggregatesFilter<"Seat"> | bigint | number
    name?: StringWithAggregatesFilter<"Seat"> | string
    minCapacity?: IntWithAggregatesFilter<"Seat"> | number
    maxCapacity?: IntWithAggregatesFilter<"Seat"> | number
    status?: EnumSeatStatusWithAggregatesFilter<"Seat"> | $Enums.SeatStatus
    createdAt?: DateTimeWithAggregatesFilter<"Seat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Seat"> | Date | string
  }

  export type LayoutWhereInput = {
    AND?: LayoutWhereInput | LayoutWhereInput[]
    OR?: LayoutWhereInput[]
    NOT?: LayoutWhereInput | LayoutWhereInput[]
    id?: BigIntFilter<"Layout"> | bigint | number
    storeId?: BigIntFilter<"Layout"> | bigint | number
    name?: StringFilter<"Layout"> | string
    status?: EnumLayoutStatusFilter<"Layout"> | $Enums.LayoutStatus
    createdAt?: DateTimeFilter<"Layout"> | Date | string
    updatedAt?: DateTimeFilter<"Layout"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    seats?: LayoutSeatListRelationFilter
  }

  export type LayoutOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    seats?: LayoutSeatOrderByRelationAggregateInput
  }

  export type LayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    storeId_name?: LayoutStoreIdNameCompoundUniqueInput
    AND?: LayoutWhereInput | LayoutWhereInput[]
    OR?: LayoutWhereInput[]
    NOT?: LayoutWhereInput | LayoutWhereInput[]
    storeId?: BigIntFilter<"Layout"> | bigint | number
    name?: StringFilter<"Layout"> | string
    status?: EnumLayoutStatusFilter<"Layout"> | $Enums.LayoutStatus
    createdAt?: DateTimeFilter<"Layout"> | Date | string
    updatedAt?: DateTimeFilter<"Layout"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    seats?: LayoutSeatListRelationFilter
  }, "id" | "storeId_name">

  export type LayoutOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LayoutCountOrderByAggregateInput
    _avg?: LayoutAvgOrderByAggregateInput
    _max?: LayoutMaxOrderByAggregateInput
    _min?: LayoutMinOrderByAggregateInput
    _sum?: LayoutSumOrderByAggregateInput
  }

  export type LayoutScalarWhereWithAggregatesInput = {
    AND?: LayoutScalarWhereWithAggregatesInput | LayoutScalarWhereWithAggregatesInput[]
    OR?: LayoutScalarWhereWithAggregatesInput[]
    NOT?: LayoutScalarWhereWithAggregatesInput | LayoutScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Layout"> | bigint | number
    storeId?: BigIntWithAggregatesFilter<"Layout"> | bigint | number
    name?: StringWithAggregatesFilter<"Layout"> | string
    status?: EnumLayoutStatusWithAggregatesFilter<"Layout"> | $Enums.LayoutStatus
    createdAt?: DateTimeWithAggregatesFilter<"Layout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Layout"> | Date | string
  }

  export type LayoutSeatWhereInput = {
    AND?: LayoutSeatWhereInput | LayoutSeatWhereInput[]
    OR?: LayoutSeatWhereInput[]
    NOT?: LayoutSeatWhereInput | LayoutSeatWhereInput[]
    layoutId?: BigIntFilter<"LayoutSeat"> | bigint | number
    seatId?: BigIntFilter<"LayoutSeat"> | bigint | number
    createdAt?: DateTimeFilter<"LayoutSeat"> | Date | string
    updatedAt?: DateTimeFilter<"LayoutSeat"> | Date | string
    layout?: XOR<LayoutScalarRelationFilter, LayoutWhereInput>
    seat?: XOR<SeatScalarRelationFilter, SeatWhereInput>
  }

  export type LayoutSeatOrderByWithRelationInput = {
    layoutId?: SortOrder
    seatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    layout?: LayoutOrderByWithRelationInput
    seat?: SeatOrderByWithRelationInput
  }

  export type LayoutSeatWhereUniqueInput = Prisma.AtLeast<{
    layoutId_seatId?: LayoutSeatLayoutIdSeatIdCompoundUniqueInput
    AND?: LayoutSeatWhereInput | LayoutSeatWhereInput[]
    OR?: LayoutSeatWhereInput[]
    NOT?: LayoutSeatWhereInput | LayoutSeatWhereInput[]
    layoutId?: BigIntFilter<"LayoutSeat"> | bigint | number
    seatId?: BigIntFilter<"LayoutSeat"> | bigint | number
    createdAt?: DateTimeFilter<"LayoutSeat"> | Date | string
    updatedAt?: DateTimeFilter<"LayoutSeat"> | Date | string
    layout?: XOR<LayoutScalarRelationFilter, LayoutWhereInput>
    seat?: XOR<SeatScalarRelationFilter, SeatWhereInput>
  }, "layoutId_seatId">

  export type LayoutSeatOrderByWithAggregationInput = {
    layoutId?: SortOrder
    seatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LayoutSeatCountOrderByAggregateInput
    _avg?: LayoutSeatAvgOrderByAggregateInput
    _max?: LayoutSeatMaxOrderByAggregateInput
    _min?: LayoutSeatMinOrderByAggregateInput
    _sum?: LayoutSeatSumOrderByAggregateInput
  }

  export type LayoutSeatScalarWhereWithAggregatesInput = {
    AND?: LayoutSeatScalarWhereWithAggregatesInput | LayoutSeatScalarWhereWithAggregatesInput[]
    OR?: LayoutSeatScalarWhereWithAggregatesInput[]
    NOT?: LayoutSeatScalarWhereWithAggregatesInput | LayoutSeatScalarWhereWithAggregatesInput[]
    layoutId?: BigIntWithAggregatesFilter<"LayoutSeat"> | bigint | number
    seatId?: BigIntWithAggregatesFilter<"LayoutSeat"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"LayoutSeat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LayoutSeat"> | Date | string
  }

  export type StoreCreateInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountCreateNestedManyWithoutStoreInput
    seatAttributeGroups?: SeatAttributeGroupCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeCreateNestedManyWithoutStoreInput
    seats?: SeatCreateNestedManyWithoutStoreInput
    layouts?: LayoutCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountUncheckedCreateNestedManyWithoutStoreInput
    seatAttributeGroups?: SeatAttributeGroupUncheckedCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeUncheckedCreateNestedManyWithoutStoreInput
    seats?: SeatUncheckedCreateNestedManyWithoutStoreInput
    layouts?: LayoutUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUpdateManyWithoutStoreNestedInput
    seatAttributeGroups?: SeatAttributeGroupUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUpdateManyWithoutStoreNestedInput
    seats?: SeatUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUncheckedUpdateManyWithoutStoreNestedInput
    seatAttributeGroups?: SeatAttributeGroupUncheckedUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUncheckedUpdateManyWithoutStoreNestedInput
    seats?: SeatUncheckedUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateManyInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountCreateInput = {
    id?: bigint | number
    role: $Enums.Role
    userId: string
    username: string
    passwordHash: string
    status?: $Enums.UserStatus
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutUsersInput
  }

  export type UserAccountUncheckedCreateInput = {
    id?: bigint | number
    storeId?: bigint | number | null
    role: $Enums.Role
    userId: string
    username: string
    passwordHash: string
    status?: $Enums.UserStatus
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAccountUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutUsersNestedInput
  }

  export type UserAccountUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountCreateManyInput = {
    id?: bigint | number
    storeId?: bigint | number | null
    role: $Enums.Role
    userId: string
    username: string
    passwordHash: string
    status?: $Enums.UserStatus
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAccountUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeGroupCreateInput = {
    id?: bigint | number
    name: string
    selectionType: $Enums.SelectionType
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSeatAttributeGroupsInput
    attributes?: SeatAttributeCreateNestedManyWithoutGroupInput
  }

  export type SeatAttributeGroupUncheckedCreateInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    selectionType: $Enums.SelectionType
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: SeatAttributeUncheckedCreateNestedManyWithoutGroupInput
  }

  export type SeatAttributeGroupUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    selectionType?: EnumSelectionTypeFieldUpdateOperationsInput | $Enums.SelectionType
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSeatAttributeGroupsNestedInput
    attributes?: SeatAttributeUpdateManyWithoutGroupNestedInput
  }

  export type SeatAttributeGroupUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    selectionType?: EnumSelectionTypeFieldUpdateOperationsInput | $Enums.SelectionType
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: SeatAttributeUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type SeatAttributeGroupCreateManyInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    selectionType: $Enums.SelectionType
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeGroupUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    selectionType?: EnumSelectionTypeFieldUpdateOperationsInput | $Enums.SelectionType
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeGroupUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    selectionType?: EnumSelectionTypeFieldUpdateOperationsInput | $Enums.SelectionType
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeCreateInput = {
    id?: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSeatAttributesInput
    group: SeatAttributeGroupCreateNestedOneWithoutAttributesInput
    assignments?: SeatAttributeAssignmentCreateNestedManyWithoutAttributeInput
  }

  export type SeatAttributeUncheckedCreateInput = {
    id?: bigint | number
    storeId: bigint | number
    groupId: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: SeatAttributeAssignmentUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type SeatAttributeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSeatAttributesNestedInput
    group?: SeatAttributeGroupUpdateOneRequiredWithoutAttributesNestedInput
    assignments?: SeatAttributeAssignmentUpdateManyWithoutAttributeNestedInput
  }

  export type SeatAttributeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    groupId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: SeatAttributeAssignmentUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type SeatAttributeCreateManyInput = {
    id?: bigint | number
    storeId: bigint | number
    groupId: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    groupId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeAssignmentCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    seat: SeatCreateNestedOneWithoutAttributesInput
    attribute: SeatAttributeCreateNestedOneWithoutAssignmentsInput
  }

  export type SeatAttributeAssignmentUncheckedCreateInput = {
    seatId: bigint | number
    attributeId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeAssignmentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: SeatUpdateOneRequiredWithoutAttributesNestedInput
    attribute?: SeatAttributeUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type SeatAttributeAssignmentUncheckedUpdateInput = {
    seatId?: BigIntFieldUpdateOperationsInput | bigint | number
    attributeId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeAssignmentCreateManyInput = {
    seatId: bigint | number
    attributeId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeAssignmentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeAssignmentUncheckedUpdateManyInput = {
    seatId?: BigIntFieldUpdateOperationsInput | bigint | number
    attributeId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatCreateInput = {
    id?: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSeatsInput
    attributes?: SeatAttributeAssignmentCreateNestedManyWithoutSeatInput
    layouts?: LayoutSeatCreateNestedManyWithoutSeatInput
  }

  export type SeatUncheckedCreateInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: SeatAttributeAssignmentUncheckedCreateNestedManyWithoutSeatInput
    layouts?: LayoutSeatUncheckedCreateNestedManyWithoutSeatInput
  }

  export type SeatUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSeatsNestedInput
    attributes?: SeatAttributeAssignmentUpdateManyWithoutSeatNestedInput
    layouts?: LayoutSeatUpdateManyWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: SeatAttributeAssignmentUncheckedUpdateManyWithoutSeatNestedInput
    layouts?: LayoutSeatUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type SeatCreateManyInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutCreateInput = {
    id?: bigint | number
    name: string
    status?: $Enums.LayoutStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutLayoutsInput
    seats?: LayoutSeatCreateNestedManyWithoutLayoutInput
  }

  export type LayoutUncheckedCreateInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    status?: $Enums.LayoutStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: LayoutSeatUncheckedCreateNestedManyWithoutLayoutInput
  }

  export type LayoutUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLayoutStatusFieldUpdateOperationsInput | $Enums.LayoutStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutLayoutsNestedInput
    seats?: LayoutSeatUpdateManyWithoutLayoutNestedInput
  }

  export type LayoutUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLayoutStatusFieldUpdateOperationsInput | $Enums.LayoutStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: LayoutSeatUncheckedUpdateManyWithoutLayoutNestedInput
  }

  export type LayoutCreateManyInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    status?: $Enums.LayoutStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLayoutStatusFieldUpdateOperationsInput | $Enums.LayoutStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLayoutStatusFieldUpdateOperationsInput | $Enums.LayoutStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutSeatCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    layout: LayoutCreateNestedOneWithoutSeatsInput
    seat: SeatCreateNestedOneWithoutLayoutsInput
  }

  export type LayoutSeatUncheckedCreateInput = {
    layoutId: bigint | number
    seatId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutSeatUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    layout?: LayoutUpdateOneRequiredWithoutSeatsNestedInput
    seat?: SeatUpdateOneRequiredWithoutLayoutsNestedInput
  }

  export type LayoutSeatUncheckedUpdateInput = {
    layoutId?: BigIntFieldUpdateOperationsInput | bigint | number
    seatId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutSeatCreateManyInput = {
    layoutId: bigint | number
    seatId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutSeatUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutSeatUncheckedUpdateManyInput = {
    layoutId?: BigIntFieldUpdateOperationsInput | bigint | number
    seatId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumStoreStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreStatus | EnumStoreStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreStatus[] | ListEnumStoreStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreStatus[] | ListEnumStoreStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreStatusFilter<$PrismaModel> | $Enums.StoreStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserAccountListRelationFilter = {
    every?: UserAccountWhereInput
    some?: UserAccountWhereInput
    none?: UserAccountWhereInput
  }

  export type SeatAttributeGroupListRelationFilter = {
    every?: SeatAttributeGroupWhereInput
    some?: SeatAttributeGroupWhereInput
    none?: SeatAttributeGroupWhereInput
  }

  export type SeatAttributeListRelationFilter = {
    every?: SeatAttributeWhereInput
    some?: SeatAttributeWhereInput
    none?: SeatAttributeWhereInput
  }

  export type SeatListRelationFilter = {
    every?: SeatWhereInput
    some?: SeatWhereInput
    none?: SeatWhereInput
  }

  export type LayoutListRelationFilter = {
    every?: LayoutWhereInput
    some?: LayoutWhereInput
    none?: LayoutWhereInput
  }

  export type UserAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatAttributeGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumStoreStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreStatus | EnumStoreStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreStatus[] | ListEnumStoreStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreStatus[] | ListEnumStoreStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoreStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreStatusFilter<$PrismaModel>
    _max?: NestedEnumStoreStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StoreNullableScalarRelationFilter = {
    is?: StoreWhereInput | null
    isNot?: StoreWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserAccountCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type UserAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAccountMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAccountSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumSelectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SelectionType | EnumSelectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SelectionType[] | ListEnumSelectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SelectionType[] | ListEnumSelectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSelectionTypeFilter<$PrismaModel> | $Enums.SelectionType
  }

  export type EnumAttributeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttributeStatus | EnumAttributeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttributeStatus[] | ListEnumAttributeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttributeStatus[] | ListEnumAttributeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttributeStatusFilter<$PrismaModel> | $Enums.AttributeStatus
  }

  export type StoreScalarRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type SeatAttributeGroupStoreIdNameCompoundUniqueInput = {
    storeId: bigint | number
    name: string
  }

  export type SeatAttributeGroupCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    selectionType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAttributeGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type SeatAttributeGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    selectionType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAttributeGroupMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    selectionType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAttributeGroupSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type EnumSelectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SelectionType | EnumSelectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SelectionType[] | ListEnumSelectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SelectionType[] | ListEnumSelectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSelectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SelectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSelectionTypeFilter<$PrismaModel>
    _max?: NestedEnumSelectionTypeFilter<$PrismaModel>
  }

  export type EnumAttributeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttributeStatus | EnumAttributeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttributeStatus[] | ListEnumAttributeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttributeStatus[] | ListEnumAttributeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttributeStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttributeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttributeStatusFilter<$PrismaModel>
    _max?: NestedEnumAttributeStatusFilter<$PrismaModel>
  }

  export type SeatAttributeGroupScalarRelationFilter = {
    is?: SeatAttributeGroupWhereInput
    isNot?: SeatAttributeGroupWhereInput
  }

  export type SeatAttributeAssignmentListRelationFilter = {
    every?: SeatAttributeAssignmentWhereInput
    some?: SeatAttributeAssignmentWhereInput
    none?: SeatAttributeAssignmentWhereInput
  }

  export type SeatAttributeAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatAttributeStoreIdGroupIdNameCompoundUniqueInput = {
    storeId: bigint | number
    groupId: bigint | number
    name: string
  }

  export type SeatAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAttributeAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    groupId?: SortOrder
  }

  export type SeatAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAttributeSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    groupId?: SortOrder
  }

  export type SeatScalarRelationFilter = {
    is?: SeatWhereInput
    isNot?: SeatWhereInput
  }

  export type SeatAttributeScalarRelationFilter = {
    is?: SeatAttributeWhereInput
    isNot?: SeatAttributeWhereInput
  }

  export type SeatAttributeAssignmentSeatIdAttributeIdCompoundUniqueInput = {
    seatId: bigint | number
    attributeId: bigint | number
  }

  export type SeatAttributeAssignmentCountOrderByAggregateInput = {
    seatId?: SortOrder
    attributeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAttributeAssignmentAvgOrderByAggregateInput = {
    seatId?: SortOrder
    attributeId?: SortOrder
  }

  export type SeatAttributeAssignmentMaxOrderByAggregateInput = {
    seatId?: SortOrder
    attributeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAttributeAssignmentMinOrderByAggregateInput = {
    seatId?: SortOrder
    attributeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAttributeAssignmentSumOrderByAggregateInput = {
    seatId?: SortOrder
    attributeId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumSeatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSeatStatusFilter<$PrismaModel> | $Enums.SeatStatus
  }

  export type LayoutSeatListRelationFilter = {
    every?: LayoutSeatWhereInput
    some?: LayoutSeatWhereInput
    none?: LayoutSeatWhereInput
  }

  export type LayoutSeatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatStoreIdNameCompoundUniqueInput = {
    storeId: bigint | number
    name: string
  }

  export type SeatCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    minCapacity?: SortOrder
    maxCapacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    minCapacity?: SortOrder
    maxCapacity?: SortOrder
  }

  export type SeatMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    minCapacity?: SortOrder
    maxCapacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    minCapacity?: SortOrder
    maxCapacity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeatSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    minCapacity?: SortOrder
    maxCapacity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumSeatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSeatStatusWithAggregatesFilter<$PrismaModel> | $Enums.SeatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatStatusFilter<$PrismaModel>
    _max?: NestedEnumSeatStatusFilter<$PrismaModel>
  }

  export type EnumLayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LayoutStatus | EnumLayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LayoutStatus[] | ListEnumLayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayoutStatus[] | ListEnumLayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLayoutStatusFilter<$PrismaModel> | $Enums.LayoutStatus
  }

  export type LayoutStoreIdNameCompoundUniqueInput = {
    storeId: bigint | number
    name: string
  }

  export type LayoutCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayoutAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type LayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayoutMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayoutSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type EnumLayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LayoutStatus | EnumLayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LayoutStatus[] | ListEnumLayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayoutStatus[] | ListEnumLayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.LayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumLayoutStatusFilter<$PrismaModel>
  }

  export type LayoutScalarRelationFilter = {
    is?: LayoutWhereInput
    isNot?: LayoutWhereInput
  }

  export type LayoutSeatLayoutIdSeatIdCompoundUniqueInput = {
    layoutId: bigint | number
    seatId: bigint | number
  }

  export type LayoutSeatCountOrderByAggregateInput = {
    layoutId?: SortOrder
    seatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayoutSeatAvgOrderByAggregateInput = {
    layoutId?: SortOrder
    seatId?: SortOrder
  }

  export type LayoutSeatMaxOrderByAggregateInput = {
    layoutId?: SortOrder
    seatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayoutSeatMinOrderByAggregateInput = {
    layoutId?: SortOrder
    seatId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayoutSeatSumOrderByAggregateInput = {
    layoutId?: SortOrder
    seatId?: SortOrder
  }

  export type UserAccountCreateNestedManyWithoutStoreInput = {
    create?: XOR<UserAccountCreateWithoutStoreInput, UserAccountUncheckedCreateWithoutStoreInput> | UserAccountCreateWithoutStoreInput[] | UserAccountUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutStoreInput | UserAccountCreateOrConnectWithoutStoreInput[]
    createMany?: UserAccountCreateManyStoreInputEnvelope
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
  }

  export type SeatAttributeGroupCreateNestedManyWithoutStoreInput = {
    create?: XOR<SeatAttributeGroupCreateWithoutStoreInput, SeatAttributeGroupUncheckedCreateWithoutStoreInput> | SeatAttributeGroupCreateWithoutStoreInput[] | SeatAttributeGroupUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatAttributeGroupCreateOrConnectWithoutStoreInput | SeatAttributeGroupCreateOrConnectWithoutStoreInput[]
    createMany?: SeatAttributeGroupCreateManyStoreInputEnvelope
    connect?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
  }

  export type SeatAttributeCreateNestedManyWithoutStoreInput = {
    create?: XOR<SeatAttributeCreateWithoutStoreInput, SeatAttributeUncheckedCreateWithoutStoreInput> | SeatAttributeCreateWithoutStoreInput[] | SeatAttributeUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutStoreInput | SeatAttributeCreateOrConnectWithoutStoreInput[]
    createMany?: SeatAttributeCreateManyStoreInputEnvelope
    connect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
  }

  export type SeatCreateNestedManyWithoutStoreInput = {
    create?: XOR<SeatCreateWithoutStoreInput, SeatUncheckedCreateWithoutStoreInput> | SeatCreateWithoutStoreInput[] | SeatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutStoreInput | SeatCreateOrConnectWithoutStoreInput[]
    createMany?: SeatCreateManyStoreInputEnvelope
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
  }

  export type LayoutCreateNestedManyWithoutStoreInput = {
    create?: XOR<LayoutCreateWithoutStoreInput, LayoutUncheckedCreateWithoutStoreInput> | LayoutCreateWithoutStoreInput[] | LayoutUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: LayoutCreateOrConnectWithoutStoreInput | LayoutCreateOrConnectWithoutStoreInput[]
    createMany?: LayoutCreateManyStoreInputEnvelope
    connect?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
  }

  export type UserAccountUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<UserAccountCreateWithoutStoreInput, UserAccountUncheckedCreateWithoutStoreInput> | UserAccountCreateWithoutStoreInput[] | UserAccountUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutStoreInput | UserAccountCreateOrConnectWithoutStoreInput[]
    createMany?: UserAccountCreateManyStoreInputEnvelope
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
  }

  export type SeatAttributeGroupUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SeatAttributeGroupCreateWithoutStoreInput, SeatAttributeGroupUncheckedCreateWithoutStoreInput> | SeatAttributeGroupCreateWithoutStoreInput[] | SeatAttributeGroupUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatAttributeGroupCreateOrConnectWithoutStoreInput | SeatAttributeGroupCreateOrConnectWithoutStoreInput[]
    createMany?: SeatAttributeGroupCreateManyStoreInputEnvelope
    connect?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
  }

  export type SeatAttributeUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SeatAttributeCreateWithoutStoreInput, SeatAttributeUncheckedCreateWithoutStoreInput> | SeatAttributeCreateWithoutStoreInput[] | SeatAttributeUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutStoreInput | SeatAttributeCreateOrConnectWithoutStoreInput[]
    createMany?: SeatAttributeCreateManyStoreInputEnvelope
    connect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
  }

  export type SeatUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SeatCreateWithoutStoreInput, SeatUncheckedCreateWithoutStoreInput> | SeatCreateWithoutStoreInput[] | SeatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutStoreInput | SeatCreateOrConnectWithoutStoreInput[]
    createMany?: SeatCreateManyStoreInputEnvelope
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
  }

  export type LayoutUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<LayoutCreateWithoutStoreInput, LayoutUncheckedCreateWithoutStoreInput> | LayoutCreateWithoutStoreInput[] | LayoutUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: LayoutCreateOrConnectWithoutStoreInput | LayoutCreateOrConnectWithoutStoreInput[]
    createMany?: LayoutCreateManyStoreInputEnvelope
    connect?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumStoreStatusFieldUpdateOperationsInput = {
    set?: $Enums.StoreStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserAccountUpdateManyWithoutStoreNestedInput = {
    create?: XOR<UserAccountCreateWithoutStoreInput, UserAccountUncheckedCreateWithoutStoreInput> | UserAccountCreateWithoutStoreInput[] | UserAccountUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutStoreInput | UserAccountCreateOrConnectWithoutStoreInput[]
    upsert?: UserAccountUpsertWithWhereUniqueWithoutStoreInput | UserAccountUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: UserAccountCreateManyStoreInputEnvelope
    set?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    disconnect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    delete?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    update?: UserAccountUpdateWithWhereUniqueWithoutStoreInput | UserAccountUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: UserAccountUpdateManyWithWhereWithoutStoreInput | UserAccountUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
  }

  export type SeatAttributeGroupUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SeatAttributeGroupCreateWithoutStoreInput, SeatAttributeGroupUncheckedCreateWithoutStoreInput> | SeatAttributeGroupCreateWithoutStoreInput[] | SeatAttributeGroupUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatAttributeGroupCreateOrConnectWithoutStoreInput | SeatAttributeGroupCreateOrConnectWithoutStoreInput[]
    upsert?: SeatAttributeGroupUpsertWithWhereUniqueWithoutStoreInput | SeatAttributeGroupUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SeatAttributeGroupCreateManyStoreInputEnvelope
    set?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
    disconnect?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
    delete?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
    connect?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
    update?: SeatAttributeGroupUpdateWithWhereUniqueWithoutStoreInput | SeatAttributeGroupUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SeatAttributeGroupUpdateManyWithWhereWithoutStoreInput | SeatAttributeGroupUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SeatAttributeGroupScalarWhereInput | SeatAttributeGroupScalarWhereInput[]
  }

  export type SeatAttributeUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SeatAttributeCreateWithoutStoreInput, SeatAttributeUncheckedCreateWithoutStoreInput> | SeatAttributeCreateWithoutStoreInput[] | SeatAttributeUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutStoreInput | SeatAttributeCreateOrConnectWithoutStoreInput[]
    upsert?: SeatAttributeUpsertWithWhereUniqueWithoutStoreInput | SeatAttributeUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SeatAttributeCreateManyStoreInputEnvelope
    set?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    disconnect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    delete?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    connect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    update?: SeatAttributeUpdateWithWhereUniqueWithoutStoreInput | SeatAttributeUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SeatAttributeUpdateManyWithWhereWithoutStoreInput | SeatAttributeUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SeatAttributeScalarWhereInput | SeatAttributeScalarWhereInput[]
  }

  export type SeatUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SeatCreateWithoutStoreInput, SeatUncheckedCreateWithoutStoreInput> | SeatCreateWithoutStoreInput[] | SeatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutStoreInput | SeatCreateOrConnectWithoutStoreInput[]
    upsert?: SeatUpsertWithWhereUniqueWithoutStoreInput | SeatUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SeatCreateManyStoreInputEnvelope
    set?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    disconnect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    delete?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    update?: SeatUpdateWithWhereUniqueWithoutStoreInput | SeatUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SeatUpdateManyWithWhereWithoutStoreInput | SeatUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SeatScalarWhereInput | SeatScalarWhereInput[]
  }

  export type LayoutUpdateManyWithoutStoreNestedInput = {
    create?: XOR<LayoutCreateWithoutStoreInput, LayoutUncheckedCreateWithoutStoreInput> | LayoutCreateWithoutStoreInput[] | LayoutUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: LayoutCreateOrConnectWithoutStoreInput | LayoutCreateOrConnectWithoutStoreInput[]
    upsert?: LayoutUpsertWithWhereUniqueWithoutStoreInput | LayoutUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: LayoutCreateManyStoreInputEnvelope
    set?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
    disconnect?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
    delete?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
    connect?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
    update?: LayoutUpdateWithWhereUniqueWithoutStoreInput | LayoutUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: LayoutUpdateManyWithWhereWithoutStoreInput | LayoutUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: LayoutScalarWhereInput | LayoutScalarWhereInput[]
  }

  export type UserAccountUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<UserAccountCreateWithoutStoreInput, UserAccountUncheckedCreateWithoutStoreInput> | UserAccountCreateWithoutStoreInput[] | UserAccountUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: UserAccountCreateOrConnectWithoutStoreInput | UserAccountCreateOrConnectWithoutStoreInput[]
    upsert?: UserAccountUpsertWithWhereUniqueWithoutStoreInput | UserAccountUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: UserAccountCreateManyStoreInputEnvelope
    set?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    disconnect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    delete?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    connect?: UserAccountWhereUniqueInput | UserAccountWhereUniqueInput[]
    update?: UserAccountUpdateWithWhereUniqueWithoutStoreInput | UserAccountUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: UserAccountUpdateManyWithWhereWithoutStoreInput | UserAccountUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
  }

  export type SeatAttributeGroupUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SeatAttributeGroupCreateWithoutStoreInput, SeatAttributeGroupUncheckedCreateWithoutStoreInput> | SeatAttributeGroupCreateWithoutStoreInput[] | SeatAttributeGroupUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatAttributeGroupCreateOrConnectWithoutStoreInput | SeatAttributeGroupCreateOrConnectWithoutStoreInput[]
    upsert?: SeatAttributeGroupUpsertWithWhereUniqueWithoutStoreInput | SeatAttributeGroupUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SeatAttributeGroupCreateManyStoreInputEnvelope
    set?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
    disconnect?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
    delete?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
    connect?: SeatAttributeGroupWhereUniqueInput | SeatAttributeGroupWhereUniqueInput[]
    update?: SeatAttributeGroupUpdateWithWhereUniqueWithoutStoreInput | SeatAttributeGroupUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SeatAttributeGroupUpdateManyWithWhereWithoutStoreInput | SeatAttributeGroupUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SeatAttributeGroupScalarWhereInput | SeatAttributeGroupScalarWhereInput[]
  }

  export type SeatAttributeUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SeatAttributeCreateWithoutStoreInput, SeatAttributeUncheckedCreateWithoutStoreInput> | SeatAttributeCreateWithoutStoreInput[] | SeatAttributeUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutStoreInput | SeatAttributeCreateOrConnectWithoutStoreInput[]
    upsert?: SeatAttributeUpsertWithWhereUniqueWithoutStoreInput | SeatAttributeUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SeatAttributeCreateManyStoreInputEnvelope
    set?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    disconnect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    delete?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    connect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    update?: SeatAttributeUpdateWithWhereUniqueWithoutStoreInput | SeatAttributeUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SeatAttributeUpdateManyWithWhereWithoutStoreInput | SeatAttributeUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SeatAttributeScalarWhereInput | SeatAttributeScalarWhereInput[]
  }

  export type SeatUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SeatCreateWithoutStoreInput, SeatUncheckedCreateWithoutStoreInput> | SeatCreateWithoutStoreInput[] | SeatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutStoreInput | SeatCreateOrConnectWithoutStoreInput[]
    upsert?: SeatUpsertWithWhereUniqueWithoutStoreInput | SeatUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SeatCreateManyStoreInputEnvelope
    set?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    disconnect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    delete?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    update?: SeatUpdateWithWhereUniqueWithoutStoreInput | SeatUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SeatUpdateManyWithWhereWithoutStoreInput | SeatUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SeatScalarWhereInput | SeatScalarWhereInput[]
  }

  export type LayoutUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<LayoutCreateWithoutStoreInput, LayoutUncheckedCreateWithoutStoreInput> | LayoutCreateWithoutStoreInput[] | LayoutUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: LayoutCreateOrConnectWithoutStoreInput | LayoutCreateOrConnectWithoutStoreInput[]
    upsert?: LayoutUpsertWithWhereUniqueWithoutStoreInput | LayoutUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: LayoutCreateManyStoreInputEnvelope
    set?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
    disconnect?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
    delete?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
    connect?: LayoutWhereUniqueInput | LayoutWhereUniqueInput[]
    update?: LayoutUpdateWithWhereUniqueWithoutStoreInput | LayoutUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: LayoutUpdateManyWithWhereWithoutStoreInput | LayoutUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: LayoutScalarWhereInput | LayoutScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutUsersInput = {
    create?: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput>
    connectOrCreate?: StoreCreateOrConnectWithoutUsersInput
    connect?: StoreWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StoreUpdateOneWithoutUsersNestedInput = {
    create?: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput>
    connectOrCreate?: StoreCreateOrConnectWithoutUsersInput
    upsert?: StoreUpsertWithoutUsersInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutUsersInput, StoreUpdateWithoutUsersInput>, StoreUncheckedUpdateWithoutUsersInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StoreCreateNestedOneWithoutSeatAttributeGroupsInput = {
    create?: XOR<StoreCreateWithoutSeatAttributeGroupsInput, StoreUncheckedCreateWithoutSeatAttributeGroupsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSeatAttributeGroupsInput
    connect?: StoreWhereUniqueInput
  }

  export type SeatAttributeCreateNestedManyWithoutGroupInput = {
    create?: XOR<SeatAttributeCreateWithoutGroupInput, SeatAttributeUncheckedCreateWithoutGroupInput> | SeatAttributeCreateWithoutGroupInput[] | SeatAttributeUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutGroupInput | SeatAttributeCreateOrConnectWithoutGroupInput[]
    createMany?: SeatAttributeCreateManyGroupInputEnvelope
    connect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
  }

  export type SeatAttributeUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<SeatAttributeCreateWithoutGroupInput, SeatAttributeUncheckedCreateWithoutGroupInput> | SeatAttributeCreateWithoutGroupInput[] | SeatAttributeUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutGroupInput | SeatAttributeCreateOrConnectWithoutGroupInput[]
    createMany?: SeatAttributeCreateManyGroupInputEnvelope
    connect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
  }

  export type EnumSelectionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SelectionType
  }

  export type EnumAttributeStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttributeStatus
  }

  export type StoreUpdateOneRequiredWithoutSeatAttributeGroupsNestedInput = {
    create?: XOR<StoreCreateWithoutSeatAttributeGroupsInput, StoreUncheckedCreateWithoutSeatAttributeGroupsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSeatAttributeGroupsInput
    upsert?: StoreUpsertWithoutSeatAttributeGroupsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSeatAttributeGroupsInput, StoreUpdateWithoutSeatAttributeGroupsInput>, StoreUncheckedUpdateWithoutSeatAttributeGroupsInput>
  }

  export type SeatAttributeUpdateManyWithoutGroupNestedInput = {
    create?: XOR<SeatAttributeCreateWithoutGroupInput, SeatAttributeUncheckedCreateWithoutGroupInput> | SeatAttributeCreateWithoutGroupInput[] | SeatAttributeUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutGroupInput | SeatAttributeCreateOrConnectWithoutGroupInput[]
    upsert?: SeatAttributeUpsertWithWhereUniqueWithoutGroupInput | SeatAttributeUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: SeatAttributeCreateManyGroupInputEnvelope
    set?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    disconnect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    delete?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    connect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    update?: SeatAttributeUpdateWithWhereUniqueWithoutGroupInput | SeatAttributeUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: SeatAttributeUpdateManyWithWhereWithoutGroupInput | SeatAttributeUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: SeatAttributeScalarWhereInput | SeatAttributeScalarWhereInput[]
  }

  export type SeatAttributeUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<SeatAttributeCreateWithoutGroupInput, SeatAttributeUncheckedCreateWithoutGroupInput> | SeatAttributeCreateWithoutGroupInput[] | SeatAttributeUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutGroupInput | SeatAttributeCreateOrConnectWithoutGroupInput[]
    upsert?: SeatAttributeUpsertWithWhereUniqueWithoutGroupInput | SeatAttributeUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: SeatAttributeCreateManyGroupInputEnvelope
    set?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    disconnect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    delete?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    connect?: SeatAttributeWhereUniqueInput | SeatAttributeWhereUniqueInput[]
    update?: SeatAttributeUpdateWithWhereUniqueWithoutGroupInput | SeatAttributeUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: SeatAttributeUpdateManyWithWhereWithoutGroupInput | SeatAttributeUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: SeatAttributeScalarWhereInput | SeatAttributeScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutSeatAttributesInput = {
    create?: XOR<StoreCreateWithoutSeatAttributesInput, StoreUncheckedCreateWithoutSeatAttributesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSeatAttributesInput
    connect?: StoreWhereUniqueInput
  }

  export type SeatAttributeGroupCreateNestedOneWithoutAttributesInput = {
    create?: XOR<SeatAttributeGroupCreateWithoutAttributesInput, SeatAttributeGroupUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: SeatAttributeGroupCreateOrConnectWithoutAttributesInput
    connect?: SeatAttributeGroupWhereUniqueInput
  }

  export type SeatAttributeAssignmentCreateNestedManyWithoutAttributeInput = {
    create?: XOR<SeatAttributeAssignmentCreateWithoutAttributeInput, SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput> | SeatAttributeAssignmentCreateWithoutAttributeInput[] | SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: SeatAttributeAssignmentCreateOrConnectWithoutAttributeInput | SeatAttributeAssignmentCreateOrConnectWithoutAttributeInput[]
    createMany?: SeatAttributeAssignmentCreateManyAttributeInputEnvelope
    connect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
  }

  export type SeatAttributeAssignmentUncheckedCreateNestedManyWithoutAttributeInput = {
    create?: XOR<SeatAttributeAssignmentCreateWithoutAttributeInput, SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput> | SeatAttributeAssignmentCreateWithoutAttributeInput[] | SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: SeatAttributeAssignmentCreateOrConnectWithoutAttributeInput | SeatAttributeAssignmentCreateOrConnectWithoutAttributeInput[]
    createMany?: SeatAttributeAssignmentCreateManyAttributeInputEnvelope
    connect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
  }

  export type StoreUpdateOneRequiredWithoutSeatAttributesNestedInput = {
    create?: XOR<StoreCreateWithoutSeatAttributesInput, StoreUncheckedCreateWithoutSeatAttributesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSeatAttributesInput
    upsert?: StoreUpsertWithoutSeatAttributesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSeatAttributesInput, StoreUpdateWithoutSeatAttributesInput>, StoreUncheckedUpdateWithoutSeatAttributesInput>
  }

  export type SeatAttributeGroupUpdateOneRequiredWithoutAttributesNestedInput = {
    create?: XOR<SeatAttributeGroupCreateWithoutAttributesInput, SeatAttributeGroupUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: SeatAttributeGroupCreateOrConnectWithoutAttributesInput
    upsert?: SeatAttributeGroupUpsertWithoutAttributesInput
    connect?: SeatAttributeGroupWhereUniqueInput
    update?: XOR<XOR<SeatAttributeGroupUpdateToOneWithWhereWithoutAttributesInput, SeatAttributeGroupUpdateWithoutAttributesInput>, SeatAttributeGroupUncheckedUpdateWithoutAttributesInput>
  }

  export type SeatAttributeAssignmentUpdateManyWithoutAttributeNestedInput = {
    create?: XOR<SeatAttributeAssignmentCreateWithoutAttributeInput, SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput> | SeatAttributeAssignmentCreateWithoutAttributeInput[] | SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: SeatAttributeAssignmentCreateOrConnectWithoutAttributeInput | SeatAttributeAssignmentCreateOrConnectWithoutAttributeInput[]
    upsert?: SeatAttributeAssignmentUpsertWithWhereUniqueWithoutAttributeInput | SeatAttributeAssignmentUpsertWithWhereUniqueWithoutAttributeInput[]
    createMany?: SeatAttributeAssignmentCreateManyAttributeInputEnvelope
    set?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    disconnect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    delete?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    connect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    update?: SeatAttributeAssignmentUpdateWithWhereUniqueWithoutAttributeInput | SeatAttributeAssignmentUpdateWithWhereUniqueWithoutAttributeInput[]
    updateMany?: SeatAttributeAssignmentUpdateManyWithWhereWithoutAttributeInput | SeatAttributeAssignmentUpdateManyWithWhereWithoutAttributeInput[]
    deleteMany?: SeatAttributeAssignmentScalarWhereInput | SeatAttributeAssignmentScalarWhereInput[]
  }

  export type SeatAttributeAssignmentUncheckedUpdateManyWithoutAttributeNestedInput = {
    create?: XOR<SeatAttributeAssignmentCreateWithoutAttributeInput, SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput> | SeatAttributeAssignmentCreateWithoutAttributeInput[] | SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput[]
    connectOrCreate?: SeatAttributeAssignmentCreateOrConnectWithoutAttributeInput | SeatAttributeAssignmentCreateOrConnectWithoutAttributeInput[]
    upsert?: SeatAttributeAssignmentUpsertWithWhereUniqueWithoutAttributeInput | SeatAttributeAssignmentUpsertWithWhereUniqueWithoutAttributeInput[]
    createMany?: SeatAttributeAssignmentCreateManyAttributeInputEnvelope
    set?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    disconnect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    delete?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    connect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    update?: SeatAttributeAssignmentUpdateWithWhereUniqueWithoutAttributeInput | SeatAttributeAssignmentUpdateWithWhereUniqueWithoutAttributeInput[]
    updateMany?: SeatAttributeAssignmentUpdateManyWithWhereWithoutAttributeInput | SeatAttributeAssignmentUpdateManyWithWhereWithoutAttributeInput[]
    deleteMany?: SeatAttributeAssignmentScalarWhereInput | SeatAttributeAssignmentScalarWhereInput[]
  }

  export type SeatCreateNestedOneWithoutAttributesInput = {
    create?: XOR<SeatCreateWithoutAttributesInput, SeatUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: SeatCreateOrConnectWithoutAttributesInput
    connect?: SeatWhereUniqueInput
  }

  export type SeatAttributeCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<SeatAttributeCreateWithoutAssignmentsInput, SeatAttributeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutAssignmentsInput
    connect?: SeatAttributeWhereUniqueInput
  }

  export type SeatUpdateOneRequiredWithoutAttributesNestedInput = {
    create?: XOR<SeatCreateWithoutAttributesInput, SeatUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: SeatCreateOrConnectWithoutAttributesInput
    upsert?: SeatUpsertWithoutAttributesInput
    connect?: SeatWhereUniqueInput
    update?: XOR<XOR<SeatUpdateToOneWithWhereWithoutAttributesInput, SeatUpdateWithoutAttributesInput>, SeatUncheckedUpdateWithoutAttributesInput>
  }

  export type SeatAttributeUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<SeatAttributeCreateWithoutAssignmentsInput, SeatAttributeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: SeatAttributeCreateOrConnectWithoutAssignmentsInput
    upsert?: SeatAttributeUpsertWithoutAssignmentsInput
    connect?: SeatAttributeWhereUniqueInput
    update?: XOR<XOR<SeatAttributeUpdateToOneWithWhereWithoutAssignmentsInput, SeatAttributeUpdateWithoutAssignmentsInput>, SeatAttributeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type StoreCreateNestedOneWithoutSeatsInput = {
    create?: XOR<StoreCreateWithoutSeatsInput, StoreUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSeatsInput
    connect?: StoreWhereUniqueInput
  }

  export type SeatAttributeAssignmentCreateNestedManyWithoutSeatInput = {
    create?: XOR<SeatAttributeAssignmentCreateWithoutSeatInput, SeatAttributeAssignmentUncheckedCreateWithoutSeatInput> | SeatAttributeAssignmentCreateWithoutSeatInput[] | SeatAttributeAssignmentUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: SeatAttributeAssignmentCreateOrConnectWithoutSeatInput | SeatAttributeAssignmentCreateOrConnectWithoutSeatInput[]
    createMany?: SeatAttributeAssignmentCreateManySeatInputEnvelope
    connect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
  }

  export type LayoutSeatCreateNestedManyWithoutSeatInput = {
    create?: XOR<LayoutSeatCreateWithoutSeatInput, LayoutSeatUncheckedCreateWithoutSeatInput> | LayoutSeatCreateWithoutSeatInput[] | LayoutSeatUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: LayoutSeatCreateOrConnectWithoutSeatInput | LayoutSeatCreateOrConnectWithoutSeatInput[]
    createMany?: LayoutSeatCreateManySeatInputEnvelope
    connect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
  }

  export type SeatAttributeAssignmentUncheckedCreateNestedManyWithoutSeatInput = {
    create?: XOR<SeatAttributeAssignmentCreateWithoutSeatInput, SeatAttributeAssignmentUncheckedCreateWithoutSeatInput> | SeatAttributeAssignmentCreateWithoutSeatInput[] | SeatAttributeAssignmentUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: SeatAttributeAssignmentCreateOrConnectWithoutSeatInput | SeatAttributeAssignmentCreateOrConnectWithoutSeatInput[]
    createMany?: SeatAttributeAssignmentCreateManySeatInputEnvelope
    connect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
  }

  export type LayoutSeatUncheckedCreateNestedManyWithoutSeatInput = {
    create?: XOR<LayoutSeatCreateWithoutSeatInput, LayoutSeatUncheckedCreateWithoutSeatInput> | LayoutSeatCreateWithoutSeatInput[] | LayoutSeatUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: LayoutSeatCreateOrConnectWithoutSeatInput | LayoutSeatCreateOrConnectWithoutSeatInput[]
    createMany?: LayoutSeatCreateManySeatInputEnvelope
    connect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSeatStatusFieldUpdateOperationsInput = {
    set?: $Enums.SeatStatus
  }

  export type StoreUpdateOneRequiredWithoutSeatsNestedInput = {
    create?: XOR<StoreCreateWithoutSeatsInput, StoreUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSeatsInput
    upsert?: StoreUpsertWithoutSeatsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSeatsInput, StoreUpdateWithoutSeatsInput>, StoreUncheckedUpdateWithoutSeatsInput>
  }

  export type SeatAttributeAssignmentUpdateManyWithoutSeatNestedInput = {
    create?: XOR<SeatAttributeAssignmentCreateWithoutSeatInput, SeatAttributeAssignmentUncheckedCreateWithoutSeatInput> | SeatAttributeAssignmentCreateWithoutSeatInput[] | SeatAttributeAssignmentUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: SeatAttributeAssignmentCreateOrConnectWithoutSeatInput | SeatAttributeAssignmentCreateOrConnectWithoutSeatInput[]
    upsert?: SeatAttributeAssignmentUpsertWithWhereUniqueWithoutSeatInput | SeatAttributeAssignmentUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: SeatAttributeAssignmentCreateManySeatInputEnvelope
    set?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    disconnect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    delete?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    connect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    update?: SeatAttributeAssignmentUpdateWithWhereUniqueWithoutSeatInput | SeatAttributeAssignmentUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: SeatAttributeAssignmentUpdateManyWithWhereWithoutSeatInput | SeatAttributeAssignmentUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: SeatAttributeAssignmentScalarWhereInput | SeatAttributeAssignmentScalarWhereInput[]
  }

  export type LayoutSeatUpdateManyWithoutSeatNestedInput = {
    create?: XOR<LayoutSeatCreateWithoutSeatInput, LayoutSeatUncheckedCreateWithoutSeatInput> | LayoutSeatCreateWithoutSeatInput[] | LayoutSeatUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: LayoutSeatCreateOrConnectWithoutSeatInput | LayoutSeatCreateOrConnectWithoutSeatInput[]
    upsert?: LayoutSeatUpsertWithWhereUniqueWithoutSeatInput | LayoutSeatUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: LayoutSeatCreateManySeatInputEnvelope
    set?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    disconnect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    delete?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    connect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    update?: LayoutSeatUpdateWithWhereUniqueWithoutSeatInput | LayoutSeatUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: LayoutSeatUpdateManyWithWhereWithoutSeatInput | LayoutSeatUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: LayoutSeatScalarWhereInput | LayoutSeatScalarWhereInput[]
  }

  export type SeatAttributeAssignmentUncheckedUpdateManyWithoutSeatNestedInput = {
    create?: XOR<SeatAttributeAssignmentCreateWithoutSeatInput, SeatAttributeAssignmentUncheckedCreateWithoutSeatInput> | SeatAttributeAssignmentCreateWithoutSeatInput[] | SeatAttributeAssignmentUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: SeatAttributeAssignmentCreateOrConnectWithoutSeatInput | SeatAttributeAssignmentCreateOrConnectWithoutSeatInput[]
    upsert?: SeatAttributeAssignmentUpsertWithWhereUniqueWithoutSeatInput | SeatAttributeAssignmentUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: SeatAttributeAssignmentCreateManySeatInputEnvelope
    set?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    disconnect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    delete?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    connect?: SeatAttributeAssignmentWhereUniqueInput | SeatAttributeAssignmentWhereUniqueInput[]
    update?: SeatAttributeAssignmentUpdateWithWhereUniqueWithoutSeatInput | SeatAttributeAssignmentUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: SeatAttributeAssignmentUpdateManyWithWhereWithoutSeatInput | SeatAttributeAssignmentUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: SeatAttributeAssignmentScalarWhereInput | SeatAttributeAssignmentScalarWhereInput[]
  }

  export type LayoutSeatUncheckedUpdateManyWithoutSeatNestedInput = {
    create?: XOR<LayoutSeatCreateWithoutSeatInput, LayoutSeatUncheckedCreateWithoutSeatInput> | LayoutSeatCreateWithoutSeatInput[] | LayoutSeatUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: LayoutSeatCreateOrConnectWithoutSeatInput | LayoutSeatCreateOrConnectWithoutSeatInput[]
    upsert?: LayoutSeatUpsertWithWhereUniqueWithoutSeatInput | LayoutSeatUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: LayoutSeatCreateManySeatInputEnvelope
    set?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    disconnect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    delete?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    connect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    update?: LayoutSeatUpdateWithWhereUniqueWithoutSeatInput | LayoutSeatUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: LayoutSeatUpdateManyWithWhereWithoutSeatInput | LayoutSeatUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: LayoutSeatScalarWhereInput | LayoutSeatScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutLayoutsInput = {
    create?: XOR<StoreCreateWithoutLayoutsInput, StoreUncheckedCreateWithoutLayoutsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutLayoutsInput
    connect?: StoreWhereUniqueInput
  }

  export type LayoutSeatCreateNestedManyWithoutLayoutInput = {
    create?: XOR<LayoutSeatCreateWithoutLayoutInput, LayoutSeatUncheckedCreateWithoutLayoutInput> | LayoutSeatCreateWithoutLayoutInput[] | LayoutSeatUncheckedCreateWithoutLayoutInput[]
    connectOrCreate?: LayoutSeatCreateOrConnectWithoutLayoutInput | LayoutSeatCreateOrConnectWithoutLayoutInput[]
    createMany?: LayoutSeatCreateManyLayoutInputEnvelope
    connect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
  }

  export type LayoutSeatUncheckedCreateNestedManyWithoutLayoutInput = {
    create?: XOR<LayoutSeatCreateWithoutLayoutInput, LayoutSeatUncheckedCreateWithoutLayoutInput> | LayoutSeatCreateWithoutLayoutInput[] | LayoutSeatUncheckedCreateWithoutLayoutInput[]
    connectOrCreate?: LayoutSeatCreateOrConnectWithoutLayoutInput | LayoutSeatCreateOrConnectWithoutLayoutInput[]
    createMany?: LayoutSeatCreateManyLayoutInputEnvelope
    connect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
  }

  export type EnumLayoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.LayoutStatus
  }

  export type StoreUpdateOneRequiredWithoutLayoutsNestedInput = {
    create?: XOR<StoreCreateWithoutLayoutsInput, StoreUncheckedCreateWithoutLayoutsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutLayoutsInput
    upsert?: StoreUpsertWithoutLayoutsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutLayoutsInput, StoreUpdateWithoutLayoutsInput>, StoreUncheckedUpdateWithoutLayoutsInput>
  }

  export type LayoutSeatUpdateManyWithoutLayoutNestedInput = {
    create?: XOR<LayoutSeatCreateWithoutLayoutInput, LayoutSeatUncheckedCreateWithoutLayoutInput> | LayoutSeatCreateWithoutLayoutInput[] | LayoutSeatUncheckedCreateWithoutLayoutInput[]
    connectOrCreate?: LayoutSeatCreateOrConnectWithoutLayoutInput | LayoutSeatCreateOrConnectWithoutLayoutInput[]
    upsert?: LayoutSeatUpsertWithWhereUniqueWithoutLayoutInput | LayoutSeatUpsertWithWhereUniqueWithoutLayoutInput[]
    createMany?: LayoutSeatCreateManyLayoutInputEnvelope
    set?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    disconnect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    delete?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    connect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    update?: LayoutSeatUpdateWithWhereUniqueWithoutLayoutInput | LayoutSeatUpdateWithWhereUniqueWithoutLayoutInput[]
    updateMany?: LayoutSeatUpdateManyWithWhereWithoutLayoutInput | LayoutSeatUpdateManyWithWhereWithoutLayoutInput[]
    deleteMany?: LayoutSeatScalarWhereInput | LayoutSeatScalarWhereInput[]
  }

  export type LayoutSeatUncheckedUpdateManyWithoutLayoutNestedInput = {
    create?: XOR<LayoutSeatCreateWithoutLayoutInput, LayoutSeatUncheckedCreateWithoutLayoutInput> | LayoutSeatCreateWithoutLayoutInput[] | LayoutSeatUncheckedCreateWithoutLayoutInput[]
    connectOrCreate?: LayoutSeatCreateOrConnectWithoutLayoutInput | LayoutSeatCreateOrConnectWithoutLayoutInput[]
    upsert?: LayoutSeatUpsertWithWhereUniqueWithoutLayoutInput | LayoutSeatUpsertWithWhereUniqueWithoutLayoutInput[]
    createMany?: LayoutSeatCreateManyLayoutInputEnvelope
    set?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    disconnect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    delete?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    connect?: LayoutSeatWhereUniqueInput | LayoutSeatWhereUniqueInput[]
    update?: LayoutSeatUpdateWithWhereUniqueWithoutLayoutInput | LayoutSeatUpdateWithWhereUniqueWithoutLayoutInput[]
    updateMany?: LayoutSeatUpdateManyWithWhereWithoutLayoutInput | LayoutSeatUpdateManyWithWhereWithoutLayoutInput[]
    deleteMany?: LayoutSeatScalarWhereInput | LayoutSeatScalarWhereInput[]
  }

  export type LayoutCreateNestedOneWithoutSeatsInput = {
    create?: XOR<LayoutCreateWithoutSeatsInput, LayoutUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: LayoutCreateOrConnectWithoutSeatsInput
    connect?: LayoutWhereUniqueInput
  }

  export type SeatCreateNestedOneWithoutLayoutsInput = {
    create?: XOR<SeatCreateWithoutLayoutsInput, SeatUncheckedCreateWithoutLayoutsInput>
    connectOrCreate?: SeatCreateOrConnectWithoutLayoutsInput
    connect?: SeatWhereUniqueInput
  }

  export type LayoutUpdateOneRequiredWithoutSeatsNestedInput = {
    create?: XOR<LayoutCreateWithoutSeatsInput, LayoutUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: LayoutCreateOrConnectWithoutSeatsInput
    upsert?: LayoutUpsertWithoutSeatsInput
    connect?: LayoutWhereUniqueInput
    update?: XOR<XOR<LayoutUpdateToOneWithWhereWithoutSeatsInput, LayoutUpdateWithoutSeatsInput>, LayoutUncheckedUpdateWithoutSeatsInput>
  }

  export type SeatUpdateOneRequiredWithoutLayoutsNestedInput = {
    create?: XOR<SeatCreateWithoutLayoutsInput, SeatUncheckedCreateWithoutLayoutsInput>
    connectOrCreate?: SeatCreateOrConnectWithoutLayoutsInput
    upsert?: SeatUpsertWithoutLayoutsInput
    connect?: SeatWhereUniqueInput
    update?: XOR<XOR<SeatUpdateToOneWithWhereWithoutLayoutsInput, SeatUpdateWithoutLayoutsInput>, SeatUncheckedUpdateWithoutLayoutsInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumStoreStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreStatus | EnumStoreStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreStatus[] | ListEnumStoreStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreStatus[] | ListEnumStoreStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreStatusFilter<$PrismaModel> | $Enums.StoreStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumStoreStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreStatus | EnumStoreStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreStatus[] | ListEnumStoreStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreStatus[] | ListEnumStoreStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoreStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreStatusFilter<$PrismaModel>
    _max?: NestedEnumStoreStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSelectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SelectionType | EnumSelectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SelectionType[] | ListEnumSelectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SelectionType[] | ListEnumSelectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSelectionTypeFilter<$PrismaModel> | $Enums.SelectionType
  }

  export type NestedEnumAttributeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttributeStatus | EnumAttributeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttributeStatus[] | ListEnumAttributeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttributeStatus[] | ListEnumAttributeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttributeStatusFilter<$PrismaModel> | $Enums.AttributeStatus
  }

  export type NestedEnumSelectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SelectionType | EnumSelectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SelectionType[] | ListEnumSelectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SelectionType[] | ListEnumSelectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSelectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SelectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSelectionTypeFilter<$PrismaModel>
    _max?: NestedEnumSelectionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttributeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttributeStatus | EnumAttributeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttributeStatus[] | ListEnumAttributeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttributeStatus[] | ListEnumAttributeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttributeStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttributeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttributeStatusFilter<$PrismaModel>
    _max?: NestedEnumAttributeStatusFilter<$PrismaModel>
  }

  export type NestedEnumSeatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSeatStatusFilter<$PrismaModel> | $Enums.SeatStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumSeatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSeatStatusWithAggregatesFilter<$PrismaModel> | $Enums.SeatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatStatusFilter<$PrismaModel>
    _max?: NestedEnumSeatStatusFilter<$PrismaModel>
  }

  export type NestedEnumLayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LayoutStatus | EnumLayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LayoutStatus[] | ListEnumLayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayoutStatus[] | ListEnumLayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLayoutStatusFilter<$PrismaModel> | $Enums.LayoutStatus
  }

  export type NestedEnumLayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LayoutStatus | EnumLayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LayoutStatus[] | ListEnumLayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayoutStatus[] | ListEnumLayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.LayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumLayoutStatusFilter<$PrismaModel>
  }

  export type UserAccountCreateWithoutStoreInput = {
    id?: bigint | number
    role: $Enums.Role
    userId: string
    username: string
    passwordHash: string
    status?: $Enums.UserStatus
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAccountUncheckedCreateWithoutStoreInput = {
    id?: bigint | number
    role: $Enums.Role
    userId: string
    username: string
    passwordHash: string
    status?: $Enums.UserStatus
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAccountCreateOrConnectWithoutStoreInput = {
    where: UserAccountWhereUniqueInput
    create: XOR<UserAccountCreateWithoutStoreInput, UserAccountUncheckedCreateWithoutStoreInput>
  }

  export type UserAccountCreateManyStoreInputEnvelope = {
    data: UserAccountCreateManyStoreInput | UserAccountCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SeatAttributeGroupCreateWithoutStoreInput = {
    id?: bigint | number
    name: string
    selectionType: $Enums.SelectionType
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: SeatAttributeCreateNestedManyWithoutGroupInput
  }

  export type SeatAttributeGroupUncheckedCreateWithoutStoreInput = {
    id?: bigint | number
    name: string
    selectionType: $Enums.SelectionType
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: SeatAttributeUncheckedCreateNestedManyWithoutGroupInput
  }

  export type SeatAttributeGroupCreateOrConnectWithoutStoreInput = {
    where: SeatAttributeGroupWhereUniqueInput
    create: XOR<SeatAttributeGroupCreateWithoutStoreInput, SeatAttributeGroupUncheckedCreateWithoutStoreInput>
  }

  export type SeatAttributeGroupCreateManyStoreInputEnvelope = {
    data: SeatAttributeGroupCreateManyStoreInput | SeatAttributeGroupCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SeatAttributeCreateWithoutStoreInput = {
    id?: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    group: SeatAttributeGroupCreateNestedOneWithoutAttributesInput
    assignments?: SeatAttributeAssignmentCreateNestedManyWithoutAttributeInput
  }

  export type SeatAttributeUncheckedCreateWithoutStoreInput = {
    id?: bigint | number
    groupId: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: SeatAttributeAssignmentUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type SeatAttributeCreateOrConnectWithoutStoreInput = {
    where: SeatAttributeWhereUniqueInput
    create: XOR<SeatAttributeCreateWithoutStoreInput, SeatAttributeUncheckedCreateWithoutStoreInput>
  }

  export type SeatAttributeCreateManyStoreInputEnvelope = {
    data: SeatAttributeCreateManyStoreInput | SeatAttributeCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SeatCreateWithoutStoreInput = {
    id?: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: SeatAttributeAssignmentCreateNestedManyWithoutSeatInput
    layouts?: LayoutSeatCreateNestedManyWithoutSeatInput
  }

  export type SeatUncheckedCreateWithoutStoreInput = {
    id?: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: SeatAttributeAssignmentUncheckedCreateNestedManyWithoutSeatInput
    layouts?: LayoutSeatUncheckedCreateNestedManyWithoutSeatInput
  }

  export type SeatCreateOrConnectWithoutStoreInput = {
    where: SeatWhereUniqueInput
    create: XOR<SeatCreateWithoutStoreInput, SeatUncheckedCreateWithoutStoreInput>
  }

  export type SeatCreateManyStoreInputEnvelope = {
    data: SeatCreateManyStoreInput | SeatCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type LayoutCreateWithoutStoreInput = {
    id?: bigint | number
    name: string
    status?: $Enums.LayoutStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: LayoutSeatCreateNestedManyWithoutLayoutInput
  }

  export type LayoutUncheckedCreateWithoutStoreInput = {
    id?: bigint | number
    name: string
    status?: $Enums.LayoutStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seats?: LayoutSeatUncheckedCreateNestedManyWithoutLayoutInput
  }

  export type LayoutCreateOrConnectWithoutStoreInput = {
    where: LayoutWhereUniqueInput
    create: XOR<LayoutCreateWithoutStoreInput, LayoutUncheckedCreateWithoutStoreInput>
  }

  export type LayoutCreateManyStoreInputEnvelope = {
    data: LayoutCreateManyStoreInput | LayoutCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type UserAccountUpsertWithWhereUniqueWithoutStoreInput = {
    where: UserAccountWhereUniqueInput
    update: XOR<UserAccountUpdateWithoutStoreInput, UserAccountUncheckedUpdateWithoutStoreInput>
    create: XOR<UserAccountCreateWithoutStoreInput, UserAccountUncheckedCreateWithoutStoreInput>
  }

  export type UserAccountUpdateWithWhereUniqueWithoutStoreInput = {
    where: UserAccountWhereUniqueInput
    data: XOR<UserAccountUpdateWithoutStoreInput, UserAccountUncheckedUpdateWithoutStoreInput>
  }

  export type UserAccountUpdateManyWithWhereWithoutStoreInput = {
    where: UserAccountScalarWhereInput
    data: XOR<UserAccountUpdateManyMutationInput, UserAccountUncheckedUpdateManyWithoutStoreInput>
  }

  export type UserAccountScalarWhereInput = {
    AND?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
    OR?: UserAccountScalarWhereInput[]
    NOT?: UserAccountScalarWhereInput | UserAccountScalarWhereInput[]
    id?: BigIntFilter<"UserAccount"> | bigint | number
    storeId?: BigIntNullableFilter<"UserAccount"> | bigint | number | null
    role?: EnumRoleFilter<"UserAccount"> | $Enums.Role
    userId?: StringFilter<"UserAccount"> | string
    username?: StringFilter<"UserAccount"> | string
    passwordHash?: StringFilter<"UserAccount"> | string
    status?: EnumUserStatusFilter<"UserAccount"> | $Enums.UserStatus
    isLocked?: BoolFilter<"UserAccount"> | boolean
    createdAt?: DateTimeFilter<"UserAccount"> | Date | string
    updatedAt?: DateTimeFilter<"UserAccount"> | Date | string
  }

  export type SeatAttributeGroupUpsertWithWhereUniqueWithoutStoreInput = {
    where: SeatAttributeGroupWhereUniqueInput
    update: XOR<SeatAttributeGroupUpdateWithoutStoreInput, SeatAttributeGroupUncheckedUpdateWithoutStoreInput>
    create: XOR<SeatAttributeGroupCreateWithoutStoreInput, SeatAttributeGroupUncheckedCreateWithoutStoreInput>
  }

  export type SeatAttributeGroupUpdateWithWhereUniqueWithoutStoreInput = {
    where: SeatAttributeGroupWhereUniqueInput
    data: XOR<SeatAttributeGroupUpdateWithoutStoreInput, SeatAttributeGroupUncheckedUpdateWithoutStoreInput>
  }

  export type SeatAttributeGroupUpdateManyWithWhereWithoutStoreInput = {
    where: SeatAttributeGroupScalarWhereInput
    data: XOR<SeatAttributeGroupUpdateManyMutationInput, SeatAttributeGroupUncheckedUpdateManyWithoutStoreInput>
  }

  export type SeatAttributeGroupScalarWhereInput = {
    AND?: SeatAttributeGroupScalarWhereInput | SeatAttributeGroupScalarWhereInput[]
    OR?: SeatAttributeGroupScalarWhereInput[]
    NOT?: SeatAttributeGroupScalarWhereInput | SeatAttributeGroupScalarWhereInput[]
    id?: BigIntFilter<"SeatAttributeGroup"> | bigint | number
    storeId?: BigIntFilter<"SeatAttributeGroup"> | bigint | number
    name?: StringFilter<"SeatAttributeGroup"> | string
    selectionType?: EnumSelectionTypeFilter<"SeatAttributeGroup"> | $Enums.SelectionType
    status?: EnumAttributeStatusFilter<"SeatAttributeGroup"> | $Enums.AttributeStatus
    createdAt?: DateTimeFilter<"SeatAttributeGroup"> | Date | string
    updatedAt?: DateTimeFilter<"SeatAttributeGroup"> | Date | string
  }

  export type SeatAttributeUpsertWithWhereUniqueWithoutStoreInput = {
    where: SeatAttributeWhereUniqueInput
    update: XOR<SeatAttributeUpdateWithoutStoreInput, SeatAttributeUncheckedUpdateWithoutStoreInput>
    create: XOR<SeatAttributeCreateWithoutStoreInput, SeatAttributeUncheckedCreateWithoutStoreInput>
  }

  export type SeatAttributeUpdateWithWhereUniqueWithoutStoreInput = {
    where: SeatAttributeWhereUniqueInput
    data: XOR<SeatAttributeUpdateWithoutStoreInput, SeatAttributeUncheckedUpdateWithoutStoreInput>
  }

  export type SeatAttributeUpdateManyWithWhereWithoutStoreInput = {
    where: SeatAttributeScalarWhereInput
    data: XOR<SeatAttributeUpdateManyMutationInput, SeatAttributeUncheckedUpdateManyWithoutStoreInput>
  }

  export type SeatAttributeScalarWhereInput = {
    AND?: SeatAttributeScalarWhereInput | SeatAttributeScalarWhereInput[]
    OR?: SeatAttributeScalarWhereInput[]
    NOT?: SeatAttributeScalarWhereInput | SeatAttributeScalarWhereInput[]
    id?: BigIntFilter<"SeatAttribute"> | bigint | number
    storeId?: BigIntFilter<"SeatAttribute"> | bigint | number
    groupId?: BigIntFilter<"SeatAttribute"> | bigint | number
    name?: StringFilter<"SeatAttribute"> | string
    status?: EnumAttributeStatusFilter<"SeatAttribute"> | $Enums.AttributeStatus
    createdAt?: DateTimeFilter<"SeatAttribute"> | Date | string
    updatedAt?: DateTimeFilter<"SeatAttribute"> | Date | string
  }

  export type SeatUpsertWithWhereUniqueWithoutStoreInput = {
    where: SeatWhereUniqueInput
    update: XOR<SeatUpdateWithoutStoreInput, SeatUncheckedUpdateWithoutStoreInput>
    create: XOR<SeatCreateWithoutStoreInput, SeatUncheckedCreateWithoutStoreInput>
  }

  export type SeatUpdateWithWhereUniqueWithoutStoreInput = {
    where: SeatWhereUniqueInput
    data: XOR<SeatUpdateWithoutStoreInput, SeatUncheckedUpdateWithoutStoreInput>
  }

  export type SeatUpdateManyWithWhereWithoutStoreInput = {
    where: SeatScalarWhereInput
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyWithoutStoreInput>
  }

  export type SeatScalarWhereInput = {
    AND?: SeatScalarWhereInput | SeatScalarWhereInput[]
    OR?: SeatScalarWhereInput[]
    NOT?: SeatScalarWhereInput | SeatScalarWhereInput[]
    id?: BigIntFilter<"Seat"> | bigint | number
    storeId?: BigIntFilter<"Seat"> | bigint | number
    name?: StringFilter<"Seat"> | string
    minCapacity?: IntFilter<"Seat"> | number
    maxCapacity?: IntFilter<"Seat"> | number
    status?: EnumSeatStatusFilter<"Seat"> | $Enums.SeatStatus
    createdAt?: DateTimeFilter<"Seat"> | Date | string
    updatedAt?: DateTimeFilter<"Seat"> | Date | string
  }

  export type LayoutUpsertWithWhereUniqueWithoutStoreInput = {
    where: LayoutWhereUniqueInput
    update: XOR<LayoutUpdateWithoutStoreInput, LayoutUncheckedUpdateWithoutStoreInput>
    create: XOR<LayoutCreateWithoutStoreInput, LayoutUncheckedCreateWithoutStoreInput>
  }

  export type LayoutUpdateWithWhereUniqueWithoutStoreInput = {
    where: LayoutWhereUniqueInput
    data: XOR<LayoutUpdateWithoutStoreInput, LayoutUncheckedUpdateWithoutStoreInput>
  }

  export type LayoutUpdateManyWithWhereWithoutStoreInput = {
    where: LayoutScalarWhereInput
    data: XOR<LayoutUpdateManyMutationInput, LayoutUncheckedUpdateManyWithoutStoreInput>
  }

  export type LayoutScalarWhereInput = {
    AND?: LayoutScalarWhereInput | LayoutScalarWhereInput[]
    OR?: LayoutScalarWhereInput[]
    NOT?: LayoutScalarWhereInput | LayoutScalarWhereInput[]
    id?: BigIntFilter<"Layout"> | bigint | number
    storeId?: BigIntFilter<"Layout"> | bigint | number
    name?: StringFilter<"Layout"> | string
    status?: EnumLayoutStatusFilter<"Layout"> | $Enums.LayoutStatus
    createdAt?: DateTimeFilter<"Layout"> | Date | string
    updatedAt?: DateTimeFilter<"Layout"> | Date | string
  }

  export type StoreCreateWithoutUsersInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seatAttributeGroups?: SeatAttributeGroupCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeCreateNestedManyWithoutStoreInput
    seats?: SeatCreateNestedManyWithoutStoreInput
    layouts?: LayoutCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    seatAttributeGroups?: SeatAttributeGroupUncheckedCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeUncheckedCreateNestedManyWithoutStoreInput
    seats?: SeatUncheckedCreateNestedManyWithoutStoreInput
    layouts?: LayoutUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutUsersInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput>
  }

  export type StoreUpsertWithoutUsersInput = {
    update: XOR<StoreUpdateWithoutUsersInput, StoreUncheckedUpdateWithoutUsersInput>
    create: XOR<StoreCreateWithoutUsersInput, StoreUncheckedCreateWithoutUsersInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutUsersInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutUsersInput, StoreUncheckedUpdateWithoutUsersInput>
  }

  export type StoreUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatAttributeGroups?: SeatAttributeGroupUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUpdateManyWithoutStoreNestedInput
    seats?: SeatUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatAttributeGroups?: SeatAttributeGroupUncheckedUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUncheckedUpdateManyWithoutStoreNestedInput
    seats?: SeatUncheckedUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateWithoutSeatAttributeGroupsInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeCreateNestedManyWithoutStoreInput
    seats?: SeatCreateNestedManyWithoutStoreInput
    layouts?: LayoutCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutSeatAttributeGroupsInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountUncheckedCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeUncheckedCreateNestedManyWithoutStoreInput
    seats?: SeatUncheckedCreateNestedManyWithoutStoreInput
    layouts?: LayoutUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutSeatAttributeGroupsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSeatAttributeGroupsInput, StoreUncheckedCreateWithoutSeatAttributeGroupsInput>
  }

  export type SeatAttributeCreateWithoutGroupInput = {
    id?: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSeatAttributesInput
    assignments?: SeatAttributeAssignmentCreateNestedManyWithoutAttributeInput
  }

  export type SeatAttributeUncheckedCreateWithoutGroupInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: SeatAttributeAssignmentUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type SeatAttributeCreateOrConnectWithoutGroupInput = {
    where: SeatAttributeWhereUniqueInput
    create: XOR<SeatAttributeCreateWithoutGroupInput, SeatAttributeUncheckedCreateWithoutGroupInput>
  }

  export type SeatAttributeCreateManyGroupInputEnvelope = {
    data: SeatAttributeCreateManyGroupInput | SeatAttributeCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutSeatAttributeGroupsInput = {
    update: XOR<StoreUpdateWithoutSeatAttributeGroupsInput, StoreUncheckedUpdateWithoutSeatAttributeGroupsInput>
    create: XOR<StoreCreateWithoutSeatAttributeGroupsInput, StoreUncheckedCreateWithoutSeatAttributeGroupsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSeatAttributeGroupsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSeatAttributeGroupsInput, StoreUncheckedUpdateWithoutSeatAttributeGroupsInput>
  }

  export type StoreUpdateWithoutSeatAttributeGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUpdateManyWithoutStoreNestedInput
    seats?: SeatUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSeatAttributeGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUncheckedUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUncheckedUpdateManyWithoutStoreNestedInput
    seats?: SeatUncheckedUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type SeatAttributeUpsertWithWhereUniqueWithoutGroupInput = {
    where: SeatAttributeWhereUniqueInput
    update: XOR<SeatAttributeUpdateWithoutGroupInput, SeatAttributeUncheckedUpdateWithoutGroupInput>
    create: XOR<SeatAttributeCreateWithoutGroupInput, SeatAttributeUncheckedCreateWithoutGroupInput>
  }

  export type SeatAttributeUpdateWithWhereUniqueWithoutGroupInput = {
    where: SeatAttributeWhereUniqueInput
    data: XOR<SeatAttributeUpdateWithoutGroupInput, SeatAttributeUncheckedUpdateWithoutGroupInput>
  }

  export type SeatAttributeUpdateManyWithWhereWithoutGroupInput = {
    where: SeatAttributeScalarWhereInput
    data: XOR<SeatAttributeUpdateManyMutationInput, SeatAttributeUncheckedUpdateManyWithoutGroupInput>
  }

  export type StoreCreateWithoutSeatAttributesInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountCreateNestedManyWithoutStoreInput
    seatAttributeGroups?: SeatAttributeGroupCreateNestedManyWithoutStoreInput
    seats?: SeatCreateNestedManyWithoutStoreInput
    layouts?: LayoutCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutSeatAttributesInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountUncheckedCreateNestedManyWithoutStoreInput
    seatAttributeGroups?: SeatAttributeGroupUncheckedCreateNestedManyWithoutStoreInput
    seats?: SeatUncheckedCreateNestedManyWithoutStoreInput
    layouts?: LayoutUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutSeatAttributesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSeatAttributesInput, StoreUncheckedCreateWithoutSeatAttributesInput>
  }

  export type SeatAttributeGroupCreateWithoutAttributesInput = {
    id?: bigint | number
    name: string
    selectionType: $Enums.SelectionType
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSeatAttributeGroupsInput
  }

  export type SeatAttributeGroupUncheckedCreateWithoutAttributesInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    selectionType: $Enums.SelectionType
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeGroupCreateOrConnectWithoutAttributesInput = {
    where: SeatAttributeGroupWhereUniqueInput
    create: XOR<SeatAttributeGroupCreateWithoutAttributesInput, SeatAttributeGroupUncheckedCreateWithoutAttributesInput>
  }

  export type SeatAttributeAssignmentCreateWithoutAttributeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    seat: SeatCreateNestedOneWithoutAttributesInput
  }

  export type SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput = {
    seatId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeAssignmentCreateOrConnectWithoutAttributeInput = {
    where: SeatAttributeAssignmentWhereUniqueInput
    create: XOR<SeatAttributeAssignmentCreateWithoutAttributeInput, SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput>
  }

  export type SeatAttributeAssignmentCreateManyAttributeInputEnvelope = {
    data: SeatAttributeAssignmentCreateManyAttributeInput | SeatAttributeAssignmentCreateManyAttributeInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutSeatAttributesInput = {
    update: XOR<StoreUpdateWithoutSeatAttributesInput, StoreUncheckedUpdateWithoutSeatAttributesInput>
    create: XOR<StoreCreateWithoutSeatAttributesInput, StoreUncheckedCreateWithoutSeatAttributesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSeatAttributesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSeatAttributesInput, StoreUncheckedUpdateWithoutSeatAttributesInput>
  }

  export type StoreUpdateWithoutSeatAttributesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUpdateManyWithoutStoreNestedInput
    seatAttributeGroups?: SeatAttributeGroupUpdateManyWithoutStoreNestedInput
    seats?: SeatUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSeatAttributesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUncheckedUpdateManyWithoutStoreNestedInput
    seatAttributeGroups?: SeatAttributeGroupUncheckedUpdateManyWithoutStoreNestedInput
    seats?: SeatUncheckedUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type SeatAttributeGroupUpsertWithoutAttributesInput = {
    update: XOR<SeatAttributeGroupUpdateWithoutAttributesInput, SeatAttributeGroupUncheckedUpdateWithoutAttributesInput>
    create: XOR<SeatAttributeGroupCreateWithoutAttributesInput, SeatAttributeGroupUncheckedCreateWithoutAttributesInput>
    where?: SeatAttributeGroupWhereInput
  }

  export type SeatAttributeGroupUpdateToOneWithWhereWithoutAttributesInput = {
    where?: SeatAttributeGroupWhereInput
    data: XOR<SeatAttributeGroupUpdateWithoutAttributesInput, SeatAttributeGroupUncheckedUpdateWithoutAttributesInput>
  }

  export type SeatAttributeGroupUpdateWithoutAttributesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    selectionType?: EnumSelectionTypeFieldUpdateOperationsInput | $Enums.SelectionType
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSeatAttributeGroupsNestedInput
  }

  export type SeatAttributeGroupUncheckedUpdateWithoutAttributesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    selectionType?: EnumSelectionTypeFieldUpdateOperationsInput | $Enums.SelectionType
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeAssignmentUpsertWithWhereUniqueWithoutAttributeInput = {
    where: SeatAttributeAssignmentWhereUniqueInput
    update: XOR<SeatAttributeAssignmentUpdateWithoutAttributeInput, SeatAttributeAssignmentUncheckedUpdateWithoutAttributeInput>
    create: XOR<SeatAttributeAssignmentCreateWithoutAttributeInput, SeatAttributeAssignmentUncheckedCreateWithoutAttributeInput>
  }

  export type SeatAttributeAssignmentUpdateWithWhereUniqueWithoutAttributeInput = {
    where: SeatAttributeAssignmentWhereUniqueInput
    data: XOR<SeatAttributeAssignmentUpdateWithoutAttributeInput, SeatAttributeAssignmentUncheckedUpdateWithoutAttributeInput>
  }

  export type SeatAttributeAssignmentUpdateManyWithWhereWithoutAttributeInput = {
    where: SeatAttributeAssignmentScalarWhereInput
    data: XOR<SeatAttributeAssignmentUpdateManyMutationInput, SeatAttributeAssignmentUncheckedUpdateManyWithoutAttributeInput>
  }

  export type SeatAttributeAssignmentScalarWhereInput = {
    AND?: SeatAttributeAssignmentScalarWhereInput | SeatAttributeAssignmentScalarWhereInput[]
    OR?: SeatAttributeAssignmentScalarWhereInput[]
    NOT?: SeatAttributeAssignmentScalarWhereInput | SeatAttributeAssignmentScalarWhereInput[]
    seatId?: BigIntFilter<"SeatAttributeAssignment"> | bigint | number
    attributeId?: BigIntFilter<"SeatAttributeAssignment"> | bigint | number
    createdAt?: DateTimeFilter<"SeatAttributeAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"SeatAttributeAssignment"> | Date | string
  }

  export type SeatCreateWithoutAttributesInput = {
    id?: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSeatsInput
    layouts?: LayoutSeatCreateNestedManyWithoutSeatInput
  }

  export type SeatUncheckedCreateWithoutAttributesInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    layouts?: LayoutSeatUncheckedCreateNestedManyWithoutSeatInput
  }

  export type SeatCreateOrConnectWithoutAttributesInput = {
    where: SeatWhereUniqueInput
    create: XOR<SeatCreateWithoutAttributesInput, SeatUncheckedCreateWithoutAttributesInput>
  }

  export type SeatAttributeCreateWithoutAssignmentsInput = {
    id?: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSeatAttributesInput
    group: SeatAttributeGroupCreateNestedOneWithoutAttributesInput
  }

  export type SeatAttributeUncheckedCreateWithoutAssignmentsInput = {
    id?: bigint | number
    storeId: bigint | number
    groupId: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeCreateOrConnectWithoutAssignmentsInput = {
    where: SeatAttributeWhereUniqueInput
    create: XOR<SeatAttributeCreateWithoutAssignmentsInput, SeatAttributeUncheckedCreateWithoutAssignmentsInput>
  }

  export type SeatUpsertWithoutAttributesInput = {
    update: XOR<SeatUpdateWithoutAttributesInput, SeatUncheckedUpdateWithoutAttributesInput>
    create: XOR<SeatCreateWithoutAttributesInput, SeatUncheckedCreateWithoutAttributesInput>
    where?: SeatWhereInput
  }

  export type SeatUpdateToOneWithWhereWithoutAttributesInput = {
    where?: SeatWhereInput
    data: XOR<SeatUpdateWithoutAttributesInput, SeatUncheckedUpdateWithoutAttributesInput>
  }

  export type SeatUpdateWithoutAttributesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSeatsNestedInput
    layouts?: LayoutSeatUpdateManyWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateWithoutAttributesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    layouts?: LayoutSeatUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type SeatAttributeUpsertWithoutAssignmentsInput = {
    update: XOR<SeatAttributeUpdateWithoutAssignmentsInput, SeatAttributeUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<SeatAttributeCreateWithoutAssignmentsInput, SeatAttributeUncheckedCreateWithoutAssignmentsInput>
    where?: SeatAttributeWhereInput
  }

  export type SeatAttributeUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: SeatAttributeWhereInput
    data: XOR<SeatAttributeUpdateWithoutAssignmentsInput, SeatAttributeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type SeatAttributeUpdateWithoutAssignmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSeatAttributesNestedInput
    group?: SeatAttributeGroupUpdateOneRequiredWithoutAttributesNestedInput
  }

  export type SeatAttributeUncheckedUpdateWithoutAssignmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    groupId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCreateWithoutSeatsInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountCreateNestedManyWithoutStoreInput
    seatAttributeGroups?: SeatAttributeGroupCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeCreateNestedManyWithoutStoreInput
    layouts?: LayoutCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutSeatsInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountUncheckedCreateNestedManyWithoutStoreInput
    seatAttributeGroups?: SeatAttributeGroupUncheckedCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeUncheckedCreateNestedManyWithoutStoreInput
    layouts?: LayoutUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutSeatsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSeatsInput, StoreUncheckedCreateWithoutSeatsInput>
  }

  export type SeatAttributeAssignmentCreateWithoutSeatInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    attribute: SeatAttributeCreateNestedOneWithoutAssignmentsInput
  }

  export type SeatAttributeAssignmentUncheckedCreateWithoutSeatInput = {
    attributeId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeAssignmentCreateOrConnectWithoutSeatInput = {
    where: SeatAttributeAssignmentWhereUniqueInput
    create: XOR<SeatAttributeAssignmentCreateWithoutSeatInput, SeatAttributeAssignmentUncheckedCreateWithoutSeatInput>
  }

  export type SeatAttributeAssignmentCreateManySeatInputEnvelope = {
    data: SeatAttributeAssignmentCreateManySeatInput | SeatAttributeAssignmentCreateManySeatInput[]
    skipDuplicates?: boolean
  }

  export type LayoutSeatCreateWithoutSeatInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    layout: LayoutCreateNestedOneWithoutSeatsInput
  }

  export type LayoutSeatUncheckedCreateWithoutSeatInput = {
    layoutId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutSeatCreateOrConnectWithoutSeatInput = {
    where: LayoutSeatWhereUniqueInput
    create: XOR<LayoutSeatCreateWithoutSeatInput, LayoutSeatUncheckedCreateWithoutSeatInput>
  }

  export type LayoutSeatCreateManySeatInputEnvelope = {
    data: LayoutSeatCreateManySeatInput | LayoutSeatCreateManySeatInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutSeatsInput = {
    update: XOR<StoreUpdateWithoutSeatsInput, StoreUncheckedUpdateWithoutSeatsInput>
    create: XOR<StoreCreateWithoutSeatsInput, StoreUncheckedCreateWithoutSeatsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSeatsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSeatsInput, StoreUncheckedUpdateWithoutSeatsInput>
  }

  export type StoreUpdateWithoutSeatsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUpdateManyWithoutStoreNestedInput
    seatAttributeGroups?: SeatAttributeGroupUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSeatsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUncheckedUpdateManyWithoutStoreNestedInput
    seatAttributeGroups?: SeatAttributeGroupUncheckedUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUncheckedUpdateManyWithoutStoreNestedInput
    layouts?: LayoutUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type SeatAttributeAssignmentUpsertWithWhereUniqueWithoutSeatInput = {
    where: SeatAttributeAssignmentWhereUniqueInput
    update: XOR<SeatAttributeAssignmentUpdateWithoutSeatInput, SeatAttributeAssignmentUncheckedUpdateWithoutSeatInput>
    create: XOR<SeatAttributeAssignmentCreateWithoutSeatInput, SeatAttributeAssignmentUncheckedCreateWithoutSeatInput>
  }

  export type SeatAttributeAssignmentUpdateWithWhereUniqueWithoutSeatInput = {
    where: SeatAttributeAssignmentWhereUniqueInput
    data: XOR<SeatAttributeAssignmentUpdateWithoutSeatInput, SeatAttributeAssignmentUncheckedUpdateWithoutSeatInput>
  }

  export type SeatAttributeAssignmentUpdateManyWithWhereWithoutSeatInput = {
    where: SeatAttributeAssignmentScalarWhereInput
    data: XOR<SeatAttributeAssignmentUpdateManyMutationInput, SeatAttributeAssignmentUncheckedUpdateManyWithoutSeatInput>
  }

  export type LayoutSeatUpsertWithWhereUniqueWithoutSeatInput = {
    where: LayoutSeatWhereUniqueInput
    update: XOR<LayoutSeatUpdateWithoutSeatInput, LayoutSeatUncheckedUpdateWithoutSeatInput>
    create: XOR<LayoutSeatCreateWithoutSeatInput, LayoutSeatUncheckedCreateWithoutSeatInput>
  }

  export type LayoutSeatUpdateWithWhereUniqueWithoutSeatInput = {
    where: LayoutSeatWhereUniqueInput
    data: XOR<LayoutSeatUpdateWithoutSeatInput, LayoutSeatUncheckedUpdateWithoutSeatInput>
  }

  export type LayoutSeatUpdateManyWithWhereWithoutSeatInput = {
    where: LayoutSeatScalarWhereInput
    data: XOR<LayoutSeatUpdateManyMutationInput, LayoutSeatUncheckedUpdateManyWithoutSeatInput>
  }

  export type LayoutSeatScalarWhereInput = {
    AND?: LayoutSeatScalarWhereInput | LayoutSeatScalarWhereInput[]
    OR?: LayoutSeatScalarWhereInput[]
    NOT?: LayoutSeatScalarWhereInput | LayoutSeatScalarWhereInput[]
    layoutId?: BigIntFilter<"LayoutSeat"> | bigint | number
    seatId?: BigIntFilter<"LayoutSeat"> | bigint | number
    createdAt?: DateTimeFilter<"LayoutSeat"> | Date | string
    updatedAt?: DateTimeFilter<"LayoutSeat"> | Date | string
  }

  export type StoreCreateWithoutLayoutsInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountCreateNestedManyWithoutStoreInput
    seatAttributeGroups?: SeatAttributeGroupCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeCreateNestedManyWithoutStoreInput
    seats?: SeatCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutLayoutsInput = {
    id?: bigint | number
    name: string
    status?: $Enums.StoreStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserAccountUncheckedCreateNestedManyWithoutStoreInput
    seatAttributeGroups?: SeatAttributeGroupUncheckedCreateNestedManyWithoutStoreInput
    seatAttributes?: SeatAttributeUncheckedCreateNestedManyWithoutStoreInput
    seats?: SeatUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutLayoutsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutLayoutsInput, StoreUncheckedCreateWithoutLayoutsInput>
  }

  export type LayoutSeatCreateWithoutLayoutInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    seat: SeatCreateNestedOneWithoutLayoutsInput
  }

  export type LayoutSeatUncheckedCreateWithoutLayoutInput = {
    seatId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutSeatCreateOrConnectWithoutLayoutInput = {
    where: LayoutSeatWhereUniqueInput
    create: XOR<LayoutSeatCreateWithoutLayoutInput, LayoutSeatUncheckedCreateWithoutLayoutInput>
  }

  export type LayoutSeatCreateManyLayoutInputEnvelope = {
    data: LayoutSeatCreateManyLayoutInput | LayoutSeatCreateManyLayoutInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutLayoutsInput = {
    update: XOR<StoreUpdateWithoutLayoutsInput, StoreUncheckedUpdateWithoutLayoutsInput>
    create: XOR<StoreCreateWithoutLayoutsInput, StoreUncheckedCreateWithoutLayoutsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutLayoutsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutLayoutsInput, StoreUncheckedUpdateWithoutLayoutsInput>
  }

  export type StoreUpdateWithoutLayoutsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUpdateManyWithoutStoreNestedInput
    seatAttributeGroups?: SeatAttributeGroupUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUpdateManyWithoutStoreNestedInput
    seats?: SeatUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutLayoutsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusFieldUpdateOperationsInput | $Enums.StoreStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAccountUncheckedUpdateManyWithoutStoreNestedInput
    seatAttributeGroups?: SeatAttributeGroupUncheckedUpdateManyWithoutStoreNestedInput
    seatAttributes?: SeatAttributeUncheckedUpdateManyWithoutStoreNestedInput
    seats?: SeatUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type LayoutSeatUpsertWithWhereUniqueWithoutLayoutInput = {
    where: LayoutSeatWhereUniqueInput
    update: XOR<LayoutSeatUpdateWithoutLayoutInput, LayoutSeatUncheckedUpdateWithoutLayoutInput>
    create: XOR<LayoutSeatCreateWithoutLayoutInput, LayoutSeatUncheckedCreateWithoutLayoutInput>
  }

  export type LayoutSeatUpdateWithWhereUniqueWithoutLayoutInput = {
    where: LayoutSeatWhereUniqueInput
    data: XOR<LayoutSeatUpdateWithoutLayoutInput, LayoutSeatUncheckedUpdateWithoutLayoutInput>
  }

  export type LayoutSeatUpdateManyWithWhereWithoutLayoutInput = {
    where: LayoutSeatScalarWhereInput
    data: XOR<LayoutSeatUpdateManyMutationInput, LayoutSeatUncheckedUpdateManyWithoutLayoutInput>
  }

  export type LayoutCreateWithoutSeatsInput = {
    id?: bigint | number
    name: string
    status?: $Enums.LayoutStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutLayoutsInput
  }

  export type LayoutUncheckedCreateWithoutSeatsInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    status?: $Enums.LayoutStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutCreateOrConnectWithoutSeatsInput = {
    where: LayoutWhereUniqueInput
    create: XOR<LayoutCreateWithoutSeatsInput, LayoutUncheckedCreateWithoutSeatsInput>
  }

  export type SeatCreateWithoutLayoutsInput = {
    id?: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSeatsInput
    attributes?: SeatAttributeAssignmentCreateNestedManyWithoutSeatInput
  }

  export type SeatUncheckedCreateWithoutLayoutsInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attributes?: SeatAttributeAssignmentUncheckedCreateNestedManyWithoutSeatInput
  }

  export type SeatCreateOrConnectWithoutLayoutsInput = {
    where: SeatWhereUniqueInput
    create: XOR<SeatCreateWithoutLayoutsInput, SeatUncheckedCreateWithoutLayoutsInput>
  }

  export type LayoutUpsertWithoutSeatsInput = {
    update: XOR<LayoutUpdateWithoutSeatsInput, LayoutUncheckedUpdateWithoutSeatsInput>
    create: XOR<LayoutCreateWithoutSeatsInput, LayoutUncheckedCreateWithoutSeatsInput>
    where?: LayoutWhereInput
  }

  export type LayoutUpdateToOneWithWhereWithoutSeatsInput = {
    where?: LayoutWhereInput
    data: XOR<LayoutUpdateWithoutSeatsInput, LayoutUncheckedUpdateWithoutSeatsInput>
  }

  export type LayoutUpdateWithoutSeatsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLayoutStatusFieldUpdateOperationsInput | $Enums.LayoutStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutLayoutsNestedInput
  }

  export type LayoutUncheckedUpdateWithoutSeatsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLayoutStatusFieldUpdateOperationsInput | $Enums.LayoutStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatUpsertWithoutLayoutsInput = {
    update: XOR<SeatUpdateWithoutLayoutsInput, SeatUncheckedUpdateWithoutLayoutsInput>
    create: XOR<SeatCreateWithoutLayoutsInput, SeatUncheckedCreateWithoutLayoutsInput>
    where?: SeatWhereInput
  }

  export type SeatUpdateToOneWithWhereWithoutLayoutsInput = {
    where?: SeatWhereInput
    data: XOR<SeatUpdateWithoutLayoutsInput, SeatUncheckedUpdateWithoutLayoutsInput>
  }

  export type SeatUpdateWithoutLayoutsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSeatsNestedInput
    attributes?: SeatAttributeAssignmentUpdateManyWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateWithoutLayoutsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: SeatAttributeAssignmentUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type UserAccountCreateManyStoreInput = {
    id?: bigint | number
    role: $Enums.Role
    userId: string
    username: string
    passwordHash: string
    status?: $Enums.UserStatus
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeGroupCreateManyStoreInput = {
    id?: bigint | number
    name: string
    selectionType: $Enums.SelectionType
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeCreateManyStoreInput = {
    id?: bigint | number
    groupId: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatCreateManyStoreInput = {
    id?: bigint | number
    name: string
    minCapacity?: number
    maxCapacity?: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutCreateManyStoreInput = {
    id?: bigint | number
    name: string
    status?: $Enums.LayoutStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAccountUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountUncheckedUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAccountUncheckedUpdateManyWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    userId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeGroupUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    selectionType?: EnumSelectionTypeFieldUpdateOperationsInput | $Enums.SelectionType
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: SeatAttributeUpdateManyWithoutGroupNestedInput
  }

  export type SeatAttributeGroupUncheckedUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    selectionType?: EnumSelectionTypeFieldUpdateOperationsInput | $Enums.SelectionType
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: SeatAttributeUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type SeatAttributeGroupUncheckedUpdateManyWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    selectionType?: EnumSelectionTypeFieldUpdateOperationsInput | $Enums.SelectionType
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: SeatAttributeGroupUpdateOneRequiredWithoutAttributesNestedInput
    assignments?: SeatAttributeAssignmentUpdateManyWithoutAttributeNestedInput
  }

  export type SeatAttributeUncheckedUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    groupId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: SeatAttributeAssignmentUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type SeatAttributeUncheckedUpdateManyWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    groupId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: SeatAttributeAssignmentUpdateManyWithoutSeatNestedInput
    layouts?: LayoutSeatUpdateManyWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attributes?: SeatAttributeAssignmentUncheckedUpdateManyWithoutSeatNestedInput
    layouts?: LayoutSeatUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateManyWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    minCapacity?: IntFieldUpdateOperationsInput | number
    maxCapacity?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLayoutStatusFieldUpdateOperationsInput | $Enums.LayoutStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: LayoutSeatUpdateManyWithoutLayoutNestedInput
  }

  export type LayoutUncheckedUpdateWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLayoutStatusFieldUpdateOperationsInput | $Enums.LayoutStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: LayoutSeatUncheckedUpdateManyWithoutLayoutNestedInput
  }

  export type LayoutUncheckedUpdateManyWithoutStoreInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLayoutStatusFieldUpdateOperationsInput | $Enums.LayoutStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeCreateManyGroupInput = {
    id?: bigint | number
    storeId: bigint | number
    name: string
    status?: $Enums.AttributeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeUpdateWithoutGroupInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSeatAttributesNestedInput
    assignments?: SeatAttributeAssignmentUpdateManyWithoutAttributeNestedInput
  }

  export type SeatAttributeUncheckedUpdateWithoutGroupInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: SeatAttributeAssignmentUncheckedUpdateManyWithoutAttributeNestedInput
  }

  export type SeatAttributeUncheckedUpdateManyWithoutGroupInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    storeId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAttributeStatusFieldUpdateOperationsInput | $Enums.AttributeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeAssignmentCreateManyAttributeInput = {
    seatId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeAssignmentUpdateWithoutAttributeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: SeatUpdateOneRequiredWithoutAttributesNestedInput
  }

  export type SeatAttributeAssignmentUncheckedUpdateWithoutAttributeInput = {
    seatId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeAssignmentUncheckedUpdateManyWithoutAttributeInput = {
    seatId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeAssignmentCreateManySeatInput = {
    attributeId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutSeatCreateManySeatInput = {
    layoutId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeatAttributeAssignmentUpdateWithoutSeatInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attribute?: SeatAttributeUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type SeatAttributeAssignmentUncheckedUpdateWithoutSeatInput = {
    attributeId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatAttributeAssignmentUncheckedUpdateManyWithoutSeatInput = {
    attributeId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutSeatUpdateWithoutSeatInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    layout?: LayoutUpdateOneRequiredWithoutSeatsNestedInput
  }

  export type LayoutSeatUncheckedUpdateWithoutSeatInput = {
    layoutId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutSeatUncheckedUpdateManyWithoutSeatInput = {
    layoutId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutSeatCreateManyLayoutInput = {
    seatId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayoutSeatUpdateWithoutLayoutInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: SeatUpdateOneRequiredWithoutLayoutsNestedInput
  }

  export type LayoutSeatUncheckedUpdateWithoutLayoutInput = {
    seatId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayoutSeatUncheckedUpdateManyWithoutLayoutInput = {
    seatId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}